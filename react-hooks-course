<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React Hooks Course</title>
  <base href="./react-hooks-course.html">
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <link rel="stylesheet" href="./index.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon">

  <meta property="og:url" content="https://mateja176.github.io/blog/react-hooks-course.html" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="React Hooks Course" />
  <meta property="og:description"
    content="Read full article at https://mateja176.github.com/blog/react-hooks-course.html" />
  <meta property="og:image" content="https://i.imgur.com/nw1YiXw.png" />
  <meta property="og:image:width" content="125" />
  <meta property="og:image:height" content="125" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="https://mateja176.github.io/blog/react-hooks-course.html" />
  <meta name="twitter:title" content="React Hooks Course" />
  <meta name="twitter:description"
    content="Read full article at https://mateja176.github.com/blog/react-hooks-course.html" />
  <meta name="twitter:image" content="https://i.imgur.com/nw1YiXw.png" />
</head>

  <body class="stackedit">
    <section>
      <div class="toc__toggle" tabindex="0">
        <i class="material-icons">toc</i>
      </div>

      <div class="stackedit__left app-hidden">
        <div class="stackedit__toc">
          
<ul>
<li><a href="#react-hooks-course">React Hooks Course</a>
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#translating-class-patterns-to-functional-components-with-hooks">Translating class patterns to functional components with hooks</a></li>
</ul>
</li>
</ul>

        </div>
      </div>

      <main>
        <div class="stackedit__right">
          <div class="stackedit__html">
            <h1 id="react-hooks-course">React Hooks Course</h1>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#react-hooks-course">React Hooks Course</a>
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#translating-class-patterns-to-functional-components-with-hooks">Translating class patterns to functional components with hooks</a>
<ul>
<li><a href="#state-management">State management</a>
<ul>
<li><a href="#setstate">setState</a></li>
<li><a href="#usestate">useState</a></li>
<li><a href="#multiple-state-fields-with-setstate">Multiple state fields with setState</a></li>
<li><a href="#multiple-state-fields-with-usestate">Multiple state fields with useState</a></li>
<li><a href="#async-setstate">Async setState</a></li>
<li><a href="#async-usestate">Async useState</a></li>
</ul>
</li>
<li><a href="#reduced-pattern">Reduced pattern</a>
<ul>
<li><a href="#usereducer">useReducer</a></li>
<li><a href="#reducer-pattern-with-class-components">Reducer pattern with class components</a></li>
<li><a href="#usereducer-hook">useReducer hook</a></li>
<li><a href="#usereducer-with-reset">useReducer with reset</a></li>
</ul>
</li>
<li><a href="#react-context-and-hooks">React Context and Hooks</a>
<ul>
<li><a href="#componentcontexttype">Component.contextType</a></li>
<li><a href="#contextconsumer">Context.Consumer</a></li>
<li><a href="#usecontext">useContext</a></li>
</ul>
</li>
<li><a href="#ref-pattern">Ref pattern</a>
<ul>
<li><a href="#mutable-class-properties">Mutable class properties</a></li>
<li><a href="#accessing-dom-node-references">Accessing DOM node references</a></li>
<li><a href="#accessing-a-class-component-instance">Accessing a class component instance</a></li>
<li><a href="#createref">createRef</a></li>
<li><a href="#refs-and-functional-components">Refs and functional components</a></li>
<li><a href="#useref">useRef</a></li>
<li><a href="#useimperativehandle">useImperativeHandle</a></li>
</ul>
</li>
<li><a href="#lifecycle-methods">Lifecycle methods</a>
<ul>
<li><a href="#componentdidmount">componentDidMount</a></li>
<li><a href="#useeffect-on-mount">useEffect on mount</a></li>
<li><a href="#componentwillunmount">componentWillUnmount</a></li>
<li><a href="#useeffect-will-unmount">useEffect will unmount</a></li>
<li><a href="#componentdidupdate">componentDidUpdate</a></li>
<li><a href="#useeffect-did-update">useEffect did update</a></li>
<li><a href="#the-why-of-dependencies">The why of dependencies</a></li>
<li><a href="#uselayouteffect">useLayoutEffect</a></li>
</ul>
</li>
<li><a href="#properties-and-methods">Properties and methods</a>
<ul>
<li><a href="#usememo">useMemo</a></li>
<li><a href="#usecallback">useCallback</a></li>
<li><a href="#usememo-vs-reactmemo">useMemo vs React.memo</a></li>
<li><a href="#is-memoization-worth-it">Is memoization worth it</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#rules-of-hooks">Rules of hooks</a></li>
<li><a href="#usedebugvalue">useDebugValue</a></li>
<li><a href="#creating-your-own-hooks">Creating your own hooks</a>
<ul>
<li><a href="#implementing-redux-with-usecontext-and-usereducer">Implementing redux with useContext and useReducer</a></li>
<li><a href="#usefetch">useFetch</a></li>
<li><a href="#usepagination">usePagination</a></li>
<li><a href="#going-up-a-notch-with-middleware">Going up a notch with middleware</a></li>
<li><a href="#angular-like-services-and-dependency-injection">Angular like services and dependency injection</a></li>
</ul>
</li>
<li><a href="#testing-custom-hooks">Testing custom hooks</a>
<ul>
<li><a href="#testing-components-which-use-custom-hooks">Testing components which use custom hooks</a></li>
</ul>
</li>
<li><a href="#hooks-vs-hocs">Hooks vs HOC’s</a>
<ul>
<li><a href="#pros-of-hooks">Pros of hooks</a>
<ul>
<li><a href="#selecting-a-value-from-the-state-with-hocs">Selecting a value from the state with HOC’s</a></li>
<li><a href="#selecting-a-value-from-state-with-hooks">Selecting a value from state with hooks</a></li>
</ul>
</li>
<li><a href="#cons-of-hooks">Cons of hooks</a>
<ul>
<li><a href="#create-multiple-components-with-a-single-hoc">Create multiple components with a single HOC</a></li>
<li><a href="#create-multiple-components-with-a-single-hook">Create multiple components with a single hook</a></li>
<li><a href="#create-multiple-components-with-a-single-hoc-2">Create multiple components with a single HOC 2</a></li>
<li><a href="#create-multiple-components-with-a-single-hook-2">Create multiple components with a single hook 2</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#migrating-common-libraries-to-hooks">Migrating common libraries to hooks</a>
<ul>
<li><a href="#react-redux">react-redux</a></li>
<li><a href="#react-router">react-router</a></li>
<li><a href="#material-ui">material-ui</a></li>
<li><a href="#xstate">xstate</a></li>
<li><a href="#styled-components">styled-components</a></li>
<li><a href="#react-spring">react-spring</a></li>
</ul>
</li>
<li><a href="#parting-message">Parting message</a></li>
</ul>
</li>
</ul>
<p>To be able to get the most out of this course it’s best if you are already familiar with JavaScript, React and Typescript, although not necessary to follow along, is strongly recommended.</p>
<h2 id="motivation">Motivation</h2>
<p>In the words of the creators:</p>
<ul>
<li>It’s hard to reuse stateful logic between components</li>
<li>Complex components become hard to understand</li>
<li>Classes confuse both people and machines</li>
</ul>
<p>If you want to read up on the “why” of hooks you may do so by following <a href="https://reactjs.org/docs/hooks-intro.html#motivation">this</a> link.</p>
<p>There’s even an <a href="https://youtu.be/dpw9EHDh2bM">introductory video</a> on hooks by Dam Abramov</p>
<h2 id="translating-class-patterns-to-functional-components-with-hooks">Translating class patterns to functional components with hooks</h2>
<h3 id="state-management">State management</h3>
<h4 id="setstate">setState</h4>
<iframe src="https://stackblitz.com/edit/react-setstate-example" width="100%" height="500px">&#10;<h4 id="usestate">useState</h4>&#10;<iframe src="https://stackblitz.com/edit/react-usestate-demo" width="100%" height="500px"/>&#10;<p>We immediately notice that the example relying on <code>useState</code> is slimmer. For example, we didn&#8217;t have to declare the type of the name state since it was inferred based on the initial value which was once again <code>''</code>. We invoked <code>setName</code> with the new value for the name state instead of passing it an object.</p>&#10;<p>However, there are a few things to note here. When <code>setName</code> is invoked the <code>HelloContainer</code> component is rerendered with the value passed to the setter. This means that even if <code>initialValue</code> had changed by the time of the rerender, it would not   affect the name state.</p>&#10;<p>Wait a second, I got a call from the product owner. He said that the new requirement is that the greeting rendered by the <code>Hello</code> component should not change immediately as the user is typing into the input, but should instead update only when the user submits the update. Fear not, once again we can tackle the challenge using the <code>useState</code> hook. Let&#8217;s delve deeper into exploration by answering the question of how to handle multiple state fields.</p>&#10;<h4 id="multiple-state-fields-with-setstate">Multiple state fields with setState</h4>&#10;<iframe src="https://stackblitz.com/edit/react-setstate-mutiple" width="100%" height="500px"/>&#10;<h4 id="multiple-state-fields-with-usestate">Multiple state fields with useState</h4>&#10;<iframe src="https://stackblitz.com/edit/react-usestate-mutiple" width="100%" height="500px"/>&#10;<p>This was fairly easy. However, you might ask: Why did we have to add another <code>useState</code> hook. This brings us to another notable difference. Namely, the <code>useState</code> setter does not merge the argument with the rest of the state. Meaning that  you would have to spread the current state in order to perform a partial update. Hence it is generally recommended to combine your state fields into an object if they are being set simultaneously.</p>&#10;<p>Wait, it&#8217;s the product owner again. The new business rule states that greeting should only update a second after the user submitted. And on top of that, if the user updates the value during the second after submitting, the name should be updated with the most recent value. This sounds complicated, but it is in fact easy to implement! Similarly to <code>setState</code>, the setter function which is the second element of the array returned by the <code>useState</code> also accepts a callback function which guaranteed to be invoked with the latest value. Enough of the talk.</p>&#10;<h4 id="async-setstate">Async setState</h4>&#10;<iframe src="https://stackblitz.com/edit/react-async-setstate" width="100%" height="500px"/>&#10;<h4 id="async-usestate">Async useState</h4>&#10;<iframe src="https://stackblitz.com/edit/react-async-usestate" width="100%" height="500px"/>&#10;<p>Notice that we invoked <code>setName</code> inside the callback passed to <code>setValue</code>. The alternative would have been to combine the two state fields into an single object. However, this would mean that in order to update either <code>value</code> or <code>name</code>, we would have to spread the current state along with providing a new value for the given field. But wait, it&#8217;s not the product owner this time, instead it is a colleague from the development team.</p>&#10;<blockquote>&#10;<p>What if the state update logic becomes complex or the state involves multiple sub-values? Is this the point where we reach for redux?</p>&#10;</blockquote>&#10;<p>I&#8217;m glad you asked my friend, and the answer is no, not necessarily. Let&#8217;s consider the following hook which is a close cousin to the <code>useState</code> hook in the next section.</p>&#10;<h3 id="reduced-pattern">Reduced pattern</h3>&#10;<h4 id="usereducer">useReducer</h4>&#10;<p>As mentioned above and as it is said in the official <a href="https://reactjs.org/docs/hooks-reference.html#usereducer">docs</a>:</p>&#10;<blockquote>&#10;<p><code>useReducer</code> is usually preferable to <code>useState</code> when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one.<br/>&#10;<code>useReducer</code> also lets you optimize performance for components that trigger deep updates because <a href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">you can pass  <code>dispatch</code>  down instead of callbacks</a>.</p>&#10;</blockquote>&#10;<p>Now, this pattern is not something which was carried over from the class component pattern, however we can still implement it using class components. And below is an example of what a possible implementation may look like.</p>&#10;<h4 id="reducer-pattern-with-class-components">Reducer pattern with class components</h4>&#10;<iframe src="https://stackblitz.com/edit/react-reducer-pattern" width="100%" height="500px"/>&#10;<p>The above approach is quite verbose however is more scalable. Now let&#8217;s pay a visit to the man of the hour, low and behold the <code>useReducer</code> hook.</p>&#10;<h4 id="usereducer-hook">useReducer hook</h4>&#10;<iframe src="https://stackblitz.com/edit/react-usereducer-example" width="100%" height="500px"/>&#10;<p>First of all, you may have noticed that the <code>reducer</code> function is declared outside out the component and as such it is not coupled to the component. This means that the logic for updating the state is replaced and reused in other places, it is effectively abstracted away from the component. On top that, the update logic is easier to maintain, since adding and updating of individual cases is straightforward. However, there&#8217;s more to it as we will discuss in the <strong>Creating your own hooks</strong> section. In a nutshell, our reducer is a pure function. Hence the missing puzzle piece is the ability to perform side effects. Luckily for us the redux architecture is easily extensible with <a href="https://redux.js.org/glossary#middlewareh">middleware</a>. In the case of the <code>useReducer</code> hook, we can create quasi <a href="https://www.npmjs.com/package/redux-thunk">thunks</a> and <a href="https://redux-observable.js.org/docs/basics/Epics.html">epics</a> and more. Let&#8217;s first complete our tour of available React hooks. With a very powerful effectful pattern.</p>&#10;<h4 id="usereducer-with-reset">useReducer with reset</h4>&#10;<p>As an added bonus, let&#8217;s go through an example of how to reset the reducer state.</p>&#10;<iframe src="https://stackblitz.com/edit/react-usereducer-with-reset" width="100%" height="500px"/>&#10;<p>It&#8217;s nothing too crazy.</p>&#10;<h3 id="react-context-and-hooks">React Context and Hooks</h3>&#10;<p>If <code>useReducer</code> impressed you just wait until you see the next hook which is related to a very powerful React API, namely, the <a href="https://reactjs.org/docs/context.html">Context API</a>. We&#8217;ll soon be exploring the examples, however first comes a practical refresher how to use the Context API. It all starts with the context creation using <code>React.createContext</code>. It&#8217;s straightforward, the <code>createContext</code> function accepts an initial value. Based on the shape of the initial value, React is going to determine the type of the context, or the other way around - if you provide a type argument React is going to enforce the type of the initial value and all future values whom you&#8217;re going to set the context with.</p>&#10;<h4 id="component.contexttype">Component.contextType</h4>&#10;<iframe src="https://stackblitz.com/edit/react-contextype" width="100%" height="500px"/>&#10;<h4 id="context.consumer">Context.Consumer</h4>&#10;<iframe src="https://stackblitz.com/edit/react-context-consumer-example" width="100%" height="500px"/>&#10;<h4 id="usecontext">useContext</h4>&#10;<iframe src="https://stackblitz.com/edit/react-usecontext-example" width="100%" height="500px"/>&#10;<h3 id="ref-pattern">Ref pattern</h3>&#10;<p>The ref pattern commonly is utilized to access DOM node references. However, a ref object is generic and can hold a reference to basically anything. The reference is mutable and we can reassign values to it over time.</p>&#10;<blockquote>&#10;<p>Something which changes over time. But, wait, isn&#8217;t the practically the definition of <strong>state</strong>?! Does this mean that refs and state are the same thing?</p>&#10;</blockquote>&#10;<p>Yes, they are similar concepts, however there is a key difference. That difference lies in the fact that mutating a ref does not cause a rerender, unlike setting the state does.</p>&#10;<p>Practically, there&#8217;s an significant difference when it comes to interaction between refs and the <code>useEffect</code> hook, compared to state and <code>useEffect</code>, but let&#8217;s not get too fast ahead of ourselves.</p>&#10;<p>Now with that behind us. Since class fields are mutable by default , the simplest way to implement the ref pattern with class components is to just declare a class property. Bear in mind that the class field syntax in not yet part of the JavaScript spec, however it is one step away from. To quote MDN:</p>&#10;<blockquote>&#10;<p>Public and private field declarations are an  <a href="https://github.com/tc39/proposal-class-fields">experimental feature (stage 3)</a>  &gt; proposed at  <a href="https://tc39.github.io/beta/">TC39</a>, the JavaScript standards committee. Support in browsers is limited, but ?&gt; the feature can be used through a build step with systems like  <a href="https://babeljs.io/">Babel</a>.</p>&#10;</blockquote>&#10;<p>The good news for React developers who are using <code>create-react-app</code> is that we are able to use more than just ES2015 language features. One of these additional language features happens to be class fields, however <a href="https://create-react-app.dev/docs/supported-browsers-features/#supported-language-features">here</a> is a complete list.</p>&#10;<h4 id="mutable-class-properties">Mutable class properties</h4>&#10;<iframe src="https://stackblitz.com/edit/react-usereducer-example" width="100%" height="500px"/>&#10;<p><em>Note</em> if the <code>handleChange</code> property from the above example were a method instead, in the form of:</p>&#10;<pre><code class="prism language-tsx">handleChange() {&#10;  /* handle change */&#10;}&#10;</code></pre>&#10;<p>Then the would not work correctly because the callback is invoked in the global context instead of the context of the class component. What this means piratically is that <code>this</code> would refer to the global object which in case of the browser is the <code>window</code> instance, whose value can be anything.  Alternatively, we could have bound the method in the constructor:</p>&#10;<pre><code class="prism language-tsx">this.handleChange.bind(this)&#10;</code></pre>&#10;<p>Which was a common practice before the introduction arrow functions and the class field syntax.</p>&#10;<p>&#8220;What&#8217;s the difference with arrow functions?&#8221; You may ask. Basically arrow functions do not have a dynamic context. Instead  they &#8220;capture&#8221; the outer context in which they are declared in.  Regardless of the context our <code>handleChange</code> function is invoked reference to <code>this</code> inside it&#8217;s body is going to refer to the component class context.</p>&#10;<p>With that in mind, that above example is still not going to function as intended. It demonstrates the difference between state and refs. The <code>console.log</code> gives us a little more insight what&#8217;s happening. Namely, the event target&#8217;s value is assigned to the name field. In the beginning the name property is equal to &#8220;Jane&#8221;. Furthermore, if you enter the letter &#8220;a&#8221; with your cursor positioned at the end of the input, the <code>handleChange</code> method is invoked with an event whose target&#8217;s value is &#8220;Janea&#8221;. Next, if you enter the letter &#8220;e&#8221;, the <code>handleChange</code> method is again going to be invoked. The question is, what is the name field&#8217;s value going to be after the assignment? Pause for a second to think about it. I&#8217;ll list out a few options:</p>&#10;<ol>&#10;<li>Jane</li>&#10;<li>Janeae</li>&#10;<li>Janea</li>&#10;<li>Janee</li>&#10;</ol>&#10;&#10;  &#10;     So what's the correct option?&#10;  &#10;  It may still be a little confusing and that is normal, but if you analyze the event step by step , like we did before, everything becomes clear. The event target's value is going to be &#34;Janee&#34; because the components render method hasn't been invoked since (granted that the parent component hasn't been rerendered either). Having established this the rest is the same as before. Namely the value of the target (input) at the time of the keyboard event taking place is &#34;Jane&#34; and the character &#34;e&#34; which was entered is appended to the end. Finally, the name value &#34;Janee&#34; is assigned to the name field.&#10;&#10;<br/>&#10;<p>Now with that out of the way. We can use this property of refs to our advantage. In certain situations you may not want to have the component rerender, but you may still want to be able to react to the user&#8217;s input. In the following scenario we&#8217;ll keep track of the number of time the user clicked on the plus button until the count reaches 5, at which point the Count component is going to unmount and rely the information about the number of clicks to it&#8217;s parent</p>&#10;<iframe src="https://stackblitz.com/edit/ref-pattern-mutable-class-properties" width="100%" height="500px"/>&#10;<p>There&#8217;s one important detail to note here. Namely, in the <code>Count</code> component&#8217;s render method it is imperative not to destructure the count field. This is because, in JavaScript, numbers  are among value types which. In contrast to reference types like objects, when a value type is assigned to a constant or variable, a new value is created and the constant or variable which is being assigned to becomes a reference to the newly created object. In this case, since we want to mutate the class property, hence we may to access the reference to the variable through the <code>this</code> object.</p>&#10;<h4 id="accessing-dom-node-references">Accessing DOM node references</h4>&#10;<p>Bear in mind the example we are about to see can be improved upon and we will do so in a subsequent section.</p>&#10;<iframe src="https://stackblitz.com/edit/accessing-dom-node-references" width="100%" height="500px"/>&#10;<p>In the example above we used the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">getBindingClientRect</a> method on the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div">HTMLDivElement</a> instance to get the element&#8217;s width and height, in pixel units, at moment in time. Next, we set the component state causing the render method to be invoked once again, this time with the updated width and height values.</p>&#10;<h4 id="accessing-a-class-component-instance">Accessing a class component instance</h4>&#10;<p>The ref prop is a special prop in the sense that you cannot access it inside a component by typing <code>this.props.ref</code> in case of class components. Although, if you pass a ref to a class component&#8217;s instance you&#8217;ll have access the instance object. Meaning that you will be able to imperatively invoke methods on the component and access public properties.</p>&#10;<blockquote>&#10;<p>When would this be useful?</p>&#10;</blockquote>&#10;<p>A prime example is setting the focus on an input element. Consider the text editor library <a href="https://npmjs.org/package/draft-js">draft-js</a>. From my experience, the library has a hockey stick like learning curve. Meaning that it is difficult to learn at first, but once you grasp the basic concepts and mechanisms it becomes rather easy to do more complicated stuff with it. To quote the official <a href="https://draftjs.org/docs/advanced-topics-managing-focus/#__docusaurus">draft-js docs</a></p>&#10;<blockquote>&#10;<p>Managing text input focus can be a tricky task within React components. The browser focus/blur API is imperative, so setting or removing focus via declarative means purely through  <code>render()</code>  tends to feel awkward and incorrect, and it requires challenging attempts at controlling focus state.<br/>&#10;With that in mind, at Facebook we often choose to expose  <code>focus()</code>  methods on components that wrap text inputs. This breaks the declarative paradigm, but it also simplifies the work needed for engineers to successfully manage focus behavior within their apps.</p>&#10;</blockquote>&#10;<iframe src="https://stackblitz.com/edit/accessing-class-component-instance" width="100%" height="500px"/>&#10;<p>The editor component is basically a <code>textarea</code>, except that it isn&#8217;t a text area but instead relies on <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Editable_content">contentEditable</a> which brings with itself a whole class of issues like cross browser inconsistencies. If you&#8217;re interested in this topic you can check out <a href="https://youtu.be/feUYwoLhE_4">video</a> by Isaac from the draft team. Luckily for us, the draft team has overcome these obstacles and presented draft-js users with a nice API.</p>&#10;<h4 id="createref">createRef</h4>&#10;<p>In the section <strong>Accessing DOM node references</strong> I told you that the example can be improved upon and the time has come to see how.</p>&#10;<iframe src="https://stackblitz.com/edit/react-create-ref" width="100%" height="500px"/>&#10;<blockquote>&#10;<p>That&#8217;s it? Doesn&#8217;t seem like much of an improvement</p>&#10;</blockquote>&#10;<p>Indeed, it&#8217;s not a quantum leap. However, we didn&#8217;t have to explicitly type the <code>editorRef</code> property. Instead we  passed the type of object whose reference we&#8217;d like to store.</p>&#10;<blockquote>&#10;<p>Why did you pass <code>EditorState | null</code>, instead of just <code>EditorState</code></p>&#10;</blockquote>&#10;<p>Thanks for the question, this ties in with the constructor which too is newly added. Inside the body of the constructor method the value of <code>this.editorRef</code> is logged. At which point the ref is equal to <code>{ current: null }</code>. We already mentioned that at the time of <code>componentDidMount</code> being invoked, refs will already have been updated. This means that the refs are updated somewhere in between the constructor phase and the before the mount phase.</p>&#10;<p>The life cycle doesn&#8217;t finished there though. In the above example there&#8217;s also an additional <code>componentWillUnmount</code> method along with the App component which renders a button, which when clicked mounts or unmounts the <code>MyEditor</code> component. Pay attention to an extra difference between manually creating a ref object compared to using <code>React.createRef</code>. Namely, React is going to take care of setting the ref object, returned by invoking <code>React.createRef</code>, to back to <code>{ current: null }</code> again.</p>&#10;<blockquote>&#10;<p>Why is this a good thing?</p>&#10;</blockquote>&#10;<p>Simply, the DOM node whose reference is stored in the class property does not exist in the DOM anymore after the component has been unmounted. React plays the role of your friend telling you that the coupon for the Indian restaurant which you were planning to spend is no longer valid because the restaurant already closed down. So going to the restaurant would be a waste.</p>&#10;<p>In conclusion, when using the <code>React.createRef</code> API to access a DOM node&#8217;s reference. Initially the ref object&#8217;s current property is going to be equal to <code>null</code>. After the constructor phase and before <code>componentDidMount</code> is invoked, the ref object&#8217;s current property is going to be a reference to the given DOM node. Finally, before <code>componentWillUnMount</code> is invoked the ref object&#8217;s current property is once again going to equal to <code>null</code>.</p>&#10;<h4 id="refs-and-functional-components">Refs and functional components</h4>&#10;<p>Functional components do not support refs out of the box, since they are stateless and not produce object instances like classes. We can however forward a ref from a functional component.</p>&#10;<iframe src="https://stackblitz.com/edit/refs-and-functional-components" width="100%" height="500px"/>&#10;<p>The first type parameter of forwardRef is the type of HTML element the ref is going to be forwarded to. Whereas the second one represents the props of the component. Furthermore, the callback passed to the forwardRef function now received an additional second argument which is the ref to be forwarded. To which element the ref is going to be forwarded exactly is up to the functional component to decide.</p>&#10;<p>Furthermore, if you&#8217;ve ever searched the web for a React component library chances are that you&#8217;ve come across <a href="https://material-ui.com">material UI</a> at some point. According to the following npm trends <a href="https://www.npmtrends.com/@material-ui/core-vs-antd-vs-react-bootstrap-vs-reactstrap-vs-semantic-ui-react">chart</a> material ui is the most popular React component library. Popularity aside, material ui is a set of react components which implement the <a href="https://material.io/design">material design spec</a>. If you&#8217;ve used any of Google&#8217;s products chances are that you&#8217;ve got a taste of the material design look and feel. Apart from that material ui has a wide assortment of component you can choose from which is ever evolving through <a href="https://npmjs.org/package/@material-ui/lab">@material-ui</a>. All of the components are well documented with lots of examples and there&#8217;s even a theming system and a <code>Box</code> component primitive. There&#8217;s also a few quirks here and there as demonstrated above.</p>&#10;<p>As a side note, I haven&#8217;t been payed to promote them, I laid out the major benefits of the library so that some of you may resonate with them.</p>&#10;<h4 id="useref">useRef</h4>&#10;<p>There was a lot to take in when in comes to refs however if you&#8217;ve come this far you may indulge in the ergonomics of the <code>useRef</code> hook.</p>&#10;<iframe src="https://stackblitz.com/edit/react-use-ref" width="100%" height="500px"/>&#10;<p>Once again, the code is quite a bit more concise. However, the <code>editorRef</code> declaration looks eerily similar to the above example where we used <code>createRef</code>.</p>&#10;<blockquote>&#10;<p>Then, what&#8217;s the difference between between <code>useRef</code> and <code>createRef</code>? What would happen if we replaced the <code>useRef</code> call above with an <code>createRef</code> invocation?</p>&#10;</blockquote>&#10;<p>You wouldn&#8217;t immediately notice a difference, however, it&#8217;s not recommended to use <code>createRef</code> inside the body of a functional component because of performance reasons. That is because <code>createRef</code> returns a new reference each time it is invoked, in this case being every time the FC is rendered. In the context of a single component life cycle, <code>useRef</code>, is always going to return the same reference.</p>&#10;<p>What a build up and culmination, but I feel like something is missing&#8230;</p>&#10;<p>Up until now, we talked about how refs can represent DOM node instances or class component instances. However we also talked about how refs can be basically anything. Furthermore, being able to access public properties on class component instance and imperatively invoke the methods seems like quite an advantage. This is, after all, a very common pattern in frameworks like Angular. This section is dedicated to the ones who asked themselves how this mechanism could be applied to functional components.</p>&#10;<p>It might not seems perfectly clear how to go forward, but for starters, we know how to forward a ref to a functional component. In a sense, a functional component is equivalent to class component instance&#8217;s render method. As such, it may be difficult to imagine how a FC can harbor properties and method. The answer  is simple. Constants and variables declared inside the function body may represent properties and functions may represent method.</p>&#10;<blockquote>&#10;<p>But, what about a shared context, through <code>this</code>?</p>&#10;</blockquote>&#10;<p>Guess what, the body of a functional component represents already context which is shared across variables and functions.</p>&#10;<p>Taking this idea a step further, in contrary to class components everything inside a FC&#8217;s body is private by default. Meaning that the outside world has no knowledge of any variables or functions declared inside it. However, we do want to expose certain variables and functions. and we can easily do so by mutating the ref&#8217;s <code>current</code> property.</p>&#10;<iframe src="https://stackblitz.com/edit/react-use-imperative-handle" width="100%" height="500px"/>&#10;<p>It works exactly like you&#8217;d expect it to. However, there are a few things to note here. Starting with the <code>if (ref)</code> inside the <code>Hello</code> component. It seems excessive according to the type signature of the <code>ref</code> which is <code>((instance: IHello) =&gt; void) | React.MutableRefObject&lt;IHello&gt;</code>. There is no mentioned of <code>null</code> or <code>undefined</code>, however if you do not pass a ref to the component upon instantiation, like <code>&lt;Hello /&gt;</code>,  then the <code>ref</code> will simply be <code>null</code> when you try to access it in the scope of the <code>Hello</code> component. Although, it&#8217;s not likely that the consumer of the <code>Hello</code> component is going to omit the ref prop it is still a very real possibility considering that the TypeScript compiler issues no warnings or errors if you instantiate the component without providing a ref. This detail may lead to a runtime error and if we don&#8217;t test how the <code>Hello</code> component renders, the error may split by development unnoticed.</p>&#10;<blockquote>&#10;<p>Okay, but what&#8217;s up with the <code>((instance: IHello) =&gt; void)</code> part?</p>&#10;</blockquote>&#10;<p>To quote the <a href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs">React docs</a>:</p>&#10;<blockquote>&#10;<p>React also supports another way to set refs called &#8220;callback refs&#8221;, which gives more fine-grain control over when refs are set and unset.<br/>&#10;Instead of passing a  <code>ref</code>  attribute created by  <code>createRef()</code>, you pass a function. The function receives the React component instance or HTML DOM element as its argument, which can be stored and accessed elsewhere.</p>&#10;</blockquote>&#10;<p>You may not need to use the option, but it&#8217;s nice to know that it exists. Although don&#8217;t shy away from pointing out TypeScript&#8217;s shortcomings, and the shortcomings of type declarations provided by library authors and developers, the main point is that TypeScript still enables us to have an insight as to how a symbol can be used based on it&#8217;s type signature. I am a very lazy person by nature and I don&#8217;t always like looking up documentation. Ideally, I like to find out how to a third part function by simply hovering over the symbol in <a href="https://code.visualstudio.com/">VSCode</a>. As a cherry on top, VSCode also has first class support for <a href="https://jsdoc.app/about-getting-started.html">JSDoc</a>, meaning that information which is difficult if not impossible to convey through types at the moment can be expressed in plain English with a comment. This way you can annotate both function, classes, object, interfaces and so on.</p>&#10;<blockquote>&#10;<p>But, wait, even if I use JavaScript in VSCode I am able to look at the type signature of the ref.</p>&#10;</blockquote>&#10;<p>That&#8217;s true, but under the hood VSCode is running a TypeScript <a href="https://github.com/microsoft/TypeScript/wiki/Standalone-Server-(tsserver)">server</a> to be able to do any type checking.</p>&#10;<p>To get back to the main branch of discussion. If the <code>ref</code> exists and <code>ref.current</code> is not of type &#8220;function&#8221;, then we can feel free to assign an object which has a clear property to <code>ref.current</code>.</p>&#10;<p>On the other hand, each time the component renders the variables and functions which are declared inside it are redeclared. The assignment to <code>ref.current</code> also needlessly happens each time. And those if checks are not very nice to look at. Not to beat around the bush anymore, there is a dedicated hook, created by the React team, for exactly this purpose.</p>&#10;<h4 id="useimperativehandle">useImperativeHandle</h4>&#10;<iframe src="https://stackblitz.com/edit/react-useimperativehandle-hook" width="100%" height="500px"/>&#10;<p>It covers all of the edge cases which we mentioned before and it provides a nice outward facing API.</p>&#10;<p>Importantly, being an imperative API, <code>useImperativeHandle</code> is not meant to be a tool which you rely on constantly because it&#8217;s not in line with React&#8217;s philosophy of functional, declarative programming. It&#8217;s not bad per se, however there is probably a more elegant and idiomatic way to perform a given task.</p>&#10;<h3 id="lifecycle-methods">Lifecycle methods</h3>&#10;<p>Hooks are used inside functional components and we already established, from the pre-hooks era, that there is no such thing as a functional component instance because it has no life cycle. There is no difference between the first render of a functional component as it is first mounted in the DOM (before it was not present in the virtual DOM hierarchy nor in the real DOM) and the last render, where the component is removed from the DOM. However, if we want to put class components aside and only use functional components, to implement the state pattern and life cycle pattern there has to be a way for developers to track the life cycle of FC&#8217;s. At least the mounting, updating and unmounting phases. Hooks bridge that gap and one such essential hook is the <code>useEffect</code> hook.</p>&#10;<p>A very important thing to note is that every hook is effectful and functional components which consume a hook are impure. A function which doesn&#8217;t perform a side effect, even if it has &#8220;use&#8221; in its name, is not a hook but a pure function.</p>&#10;<p>The convention to prefix each hook with &#8220;use&#8221; was proposed by the React team, similarly how each higher order component was prefixed with &#8220;with&#8221;. Khm <code>connect</code>, shame on you <code>react-redux</code>. The goal of the naming convention is to communicate to developers that a function has some special properties. In the case of hooks, it is the impure nature as well as the ability to trigger rerender among others. This is especially important in the case of hooks compared to HOC&#8217;s, since higher order components were distinguishable by their type signature which is:</p>&#10;<pre><code class="prism language-tsx">type HOC = &lt;InputProps, OutputProps&gt;(component: React.ComponentType&lt;InputProps&gt;) =&gt; React.ComponentType&lt;Output&gt;&#10;</code></pre>&#10;<p>Whereas, the type signature of hooks is more generic and less recognizable:</p>&#10;<pre><code class="prism language-tsx">type Hook = (...args: []) =&gt; any&#10;</code></pre>&#10;<p>In fact, the above is a type signature of any function for that matter. Based on the type signature alone, any function may or may not be a hook. However if you prefix your custom hooks with &#8220;use&#8221; is an important gesture towards your future self and other developers who are going to be working with your code. Furthermore, the highlight of this series is the <strong>Creating your own hooks</strong> section, where we&#8217;ll learn how to build world class custom hooks.</p>&#10;<p>Before we start going through all of the examples, let me ask you this.</p>&#10;&#10;  What the functional programmer answer to any object oriented pattern? &#10;  Of course, it's <i>a function</i> every time.&#10;&#10;<br/>&#10;<blockquote>&#10;<p>How does this tie in into life cycle methods?</p>&#10;</blockquote>&#10;<p>Simply, the answer to any life cycle method in the context of hooks is <a href="https://reactjs.org/docs/hooks-reference.html#useeffect">useEffect</a>.</p>&#10;<p>To understand the <code>useEffect</code> hook in it&#8217;s entirety took me quite a bit of time. Apart from reading the through the documentation I experimented a lot with the hook and through  many iterations I was able to say that I have a thorough grasp of the hook.</p>&#10;<p>In this section, we are going to go through a lot of examples step by step and incrementally learn everything you need to know to become a <code>useEffect</code> ninja.</p>&#10;<p>One more heads up before we start. Thinking in terms of utilizing the <code>useEffect</code> hook can be difficult at first since it requires a shift in perspective. However, do not beat yourself up about it. After enough practice you will build up a solid intuition.</p>&#10;<h4 id="componentdidmount">componentDidMount</h4>&#10;<h4 id="useeffect-on-mount">useEffect on mount</h4>&#10;<p>This is easy! The first argument passed to <code>useEffect</code>, as with the <code>componentDidMount</code> callback, represents a function which will be invoked by React. Now, when it is going to be invoked is more obvious in the case of <code>componentDidMount</code> based on its name. On the other hand, when it comes to <code>useEffect</code>,  when the callback is going to be invoked depends entirely on the second argument, which represents the dependencies array. The gist of it is simple. Each time a dependency changes, React will invoke the callback.</p>&#10;<p>Although React is not going to complain about it, it&#8217;s important that you pass a second argument to the <code>useEffect</code> callback. Else the callback you passed as the first argument would be invoked each time the component renders.</p>&#10;<p>However, there is a difference between invoking a function inside of the body of a FC, compared to passing a callback function to <code>useEffect</code>, even if you do not pass a second argument to <code>useEffect</code>. That being the first invocation. Namely, the naked function call is going to be invoked before the <code>usEffect</code> callback, before the component has been mounted. You may draw a parallel between the constructor invocation which happens before <code>componentDidMount</code> is called. This means that is it safer to perform any DOM related side effects as part of t <code>useEffect</code> callback.</p>&#10;<p>This topic ties into server side rendering. Entailing that your component is not going to be mounted when React is rendering your App to a string, hence <code>useEffect</code> callbacks will not be invoked during the process of server side rendering. This is a limiting circumstance at the moment because you will not be able to hydrate your app with data during server side rendering, since you cannot perform a side effect like fetching a resource inside the <code>useEffect</code> callback.</p>&#10;<p>Fortunately, with the introduction of the new <a href="https://reactjs.org/docs/concurrent-mode-adoption.html">React Concurrent Mode</a>, looking at the <a href="https://reactjs.org/docs/concurrent-mode-adoption.html#feature-comparison">feature comparison</a>, there will be first class support for server side rendering and hydration.</p>&#10;<p>If you&#8217;ve never heard of the new <code>Concurrent Mode</code>, don&#8217;t feel bad about it, since it&#8217;s pretty much brand new at the moment and it hasn&#8217;t yet fully caught on. However, <code>Concurrent Mode</code> is the future for React application since it offers so many things which were previously impossible to accomplish. Basically, the reason why it is called concurrent is because React is now able to render your app in a separate thread, without blocking the main thread. This is significant because React is not able to fully render your application&#8217;s new state before committing the update to the DOM. You can read up  e details <a href="https://reactjs.org/docs/concurrent-mode-intro.html">here</a> and even fiddle around with the Suspense API among others. Furthermore, If you guys are interested, I&#8217;d be happy to create a series, similar to this one oriented towards React&#8217;s <code>Concurrent Mode</code> .</p>&#10;<p>For now let&#8217;s focus on the topic at hand. Above I mentioned that the <code>useEffect</code> callback is going to be invoked when one of your dependencies changes. What does that mean exactly? Let&#8217;s dissect the following example to get more insight.</p>&#10;<iframe src="https://stackblitz.com/edit/react-useeffect-change-detection" width="100%" height="100%"/>&#10;<p>Clicking on <code>Turn on</code> is not going to rerender the App component, since the <code>isOn</code> state is being set to the same state as the current. Naturally, the Switch component&#8217;s <code>useEffect</code> callback is not going to fire either.  Secondly, if you click on the <code>Toggle on</code> button, the App is going to rerender followed by the Switch component. This time, since the value of the <code>isOn</code> is different compared to the previous render, React is going to invoke the <code>useEffect</code> callback.  Thirdly, if you then click on the <code>Turn on</code> button, the cycle rerenders is going to repeat. Now comes the interesting part though. The value of the <code>isOn</code> state is <code>true</code> at that moment and if you click on <code>Turn on</code> again, the App is going to rerender, as seen by the <code>console.log</code>. On the other hand, the <code>useEffect</code> callback<br/>&#10;is not invoked since the value of the <code>isOn</code> prop passed to the <code>Switch</code> component has not changed compared to the its value during the previous render.</p>&#10;<h4 id="componentwillunmount">componentWillUnmount</h4>&#10;<iframe src="https://stackblitz.com/edit/react-component-will-unmount" width="100%" height="500px"/>&#10;<p>This was pretty straight forward, with nothing out of the ordinary. Next up, we&#8217;ll see how the pattern translates to functional components and hooks.</p>&#10;<h4 id="useeffect-will-unmount">useEffect will unmount</h4>&#10;<iframe src="https://stackblitz.com/edit/react-useeffect-will-unmount" width="100%" height="500px"/>&#10;<p>Couldn&#8217;t be easier, could it? I feel like a broken record, but once again the code is more simpler and more concise.</p>&#10;<p>Now, as to what the important details in the above example are. As you probably noticed the <code>useEffect</code> callback is returning a function. This function being returned is usually aptly called the cleanup function and this is where you perform your your cleanup duties, like unsubscribing from a data source.  React will invoke that function each time the <code>useEffect</code> callback is ran, expect for the first time (this gave me a lot of confusion on the past). There&#8217;s one more exception to the rule, specifically, the cleanup function is also invoked when the component is about to be unmounted.</p>&#10;<h4 id="componentdidupdate">componentDidUpdate</h4>&#10;<p>Now that you know what React does with the dependency array in relation to the callback function and the cleanup function this section should be a breeze.</p>&#10;<iframe src="https://stackblitz.com/edit/react-componentdidutpdate-example" width="100%" height="500px"/>&#10;<p>In case that we want to perform a side effect like logging to new value of a prop to the console, each time the given prop changes, we can easily do so by utilizing the <code>componentDidUpdate</code> hook. React will invoke the callback each time any of the props change thus executing our code. This entails that the responsibility for comparing props or performing any other logic for that matter is completely up to us. You&#8217;ll soon see why this was brought up.</p>&#10;<h4 id="useeffect-did-update">useEffect did update</h4>&#10;<iframe src="https://stackblitz.com/edit/react-useeffect-did-update" width="100%" height="500px"/>&#10;<p>The dependency management mechanism is inverted in this case. Meaning that the callback is not going to be invoked unless a dependency is stated explicitly. Additionally, we do not have to perform a comparison of the props anymore, however the downside is that we do not have access to the previous props either. Although there exists a simple workaround and we going to be implementing in a section to come.</p>&#10;<p>Let&#8217;s first talk a bit more the dependencies. At this point, we know what the dependencies represent and how React manages the dependency array which we provide. Now, we are going to touch upon the why and the best practices around managing dependencies.</p>&#10;<h4 id="the-why-of-dependencies">The why of dependencies</h4>&#10;<p>So, why does the dependency array even exist. If you think about it, the compiler could conclude what the dependencies of <code>useEffect</code> callback are based on the variables which we refer to in the callback. It is possible and the React documentation even states:</p>&#10;<blockquote>&#10;<p>The array of dependencies is not passed as arguments to the effect function. Conceptually, though, that&#8217;s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</p>&#10;</blockquote>&#10;<p>This insert hints at the total removal of the dependency array. However, there would still be a need for a way to convey the information that a certain effect should be run only once. Otherwise, it would come down to an if statement inside the callback whose responsibility would be to determine whether based on the current state of the world. Something along the lines of:</p>&#10;<pre><code class="prism language-tsx">React.useEffect(() =&gt; {&#10;  if (status === 'initial') {&#10;    setStatus('loading')&#10;    fetchResource()&#10;  }&#10;})&#10;</code></pre>&#10;<h4 id="uselayouteffect">useLayoutEffect</h4>&#10;<p>The following hook, called <code>useLayoutEffect</code>, is similar to <code>useEffect</code>. In some situations the 2 of them will be interchangeable. In which case the React team recommends using <code>useEffect</code>. What follows is a great tip from the official docs:</p>&#10;<blockquote>&#10;<p>If you&#8217;re migrating code from a class component, note  <code>useLayoutEffect</code>  fires in the same phase as  <code>componentDidMount</code>  and  <code>componentDidUpdate</code>. However,  <strong>we recommend starting with  <code>useEffect</code>  first</strong>  and only trying  <code>useLayoutEffect</code>  if that causes a problem.<br/>&#10;If you use server rendering, keep in mind that  <em>neither</em>  <code>useLayoutEffect</code>  nor  <code>useEffect</code>  can run until the JavaScript is downloaded. This is why React warns when a server-rendered component contains  <code>useLayoutEffect</code>. To fix this, either move that logic to  <code>useEffect</code>  (if it isn&#8217;t necessary for the first render), or delay showing that component until after the client renders (if the HTML looks broken until  <code>useLayoutEffect</code>  runs).<br/>&#10;To exclude a component that needs layout effects from the server-rendered HTML, render it conditionally with  <code>showChild &amp;&amp; &lt;Child /&gt;</code>  and defer showing it with  <code>useEffect(() =&gt; { setShowChild(true); }, [])</code>. This way, the UI doesn&#8217;t appear broken before hydration.</p>&#10;</blockquote>&#10;<p>It&#8217;s important to note that <code>useLayout</code> fire synchronously after all DOM mutations and gives you a chance to execute a callback at the cost of blocking rendering by preventing the browser from painting. So do not perform any blocking or heavily computational operations inside the hook if you want your component to be visible on the screen as soon as possible. Don&#8217;t even use the <code>useLayoutEffect</code> hook if you don&#8217;t have to.</p>&#10;<blockquote>&#10;<p>So what&#8217;s the hook even good for, anyway?</p>&#10;</blockquote>&#10;<p>You will know when the time comes to use it. For example, if your component needs to be aware of it&#8217;s size and position before it is rendered for the first time. If part B of the layout depends on the dimensions of part A of the layout and you want to avoid a flash of unstyled content.</p>&#10;<p>Let&#8217;s see the example:</p>&#10; <iframe src="https://stackblitz.com/edit/react-uselayouteffect" width="100%" height="500px"/>&#10;<p>This might seem like a niche use case. Regardless, the React team has got us covered. This is one of those moments which instills confidence in React as a tool all encompassing tool for building web applications.</p>&#10;<p>Lastly, you may already be familiar with the usage of <code>React.Fragment</code>, it&#8217;s a way to be able to return  multiple elements at once. They are still wrapped in a <code>React.Fragment</code> however the fragment is stripped at build time and is not present in the DOM. You may also have seen the newer syntax for fragments which is more concise, <code>&lt;&gt;/\* content \*/&lt;/&gt;</code>. Yes, they look like empty HTML tags. However the Stackblitz React TypeScript template does not support it at the moment and fails to parse the symbols. Fragments are a nice way to avoid having <a href="https://www.chillybin.com.sg/would-you-like-another-bowl-of-div-soup/">div soups</a>. Nevertheless, like any other good thing, don&#8217;t overuse them. Believe me, I got burned once when I ended up with a broken layout. Long story short, by wrapping two sections in a fragment instead of a div. The 2 sections distributed evenly across the parent flex container, instead of splitting 1 fraction among themselves. Luckily for me, it was easily noticeable.</p>&#10;<h3 id="properties-and-methods">Properties and methods</h3>&#10;<p>We talked about how functional component, with the additional of hooks, stand toe to toe with class component in almost any field. However, up until now you may have noticed that something is not quite there. In other words, if we declare a constant or function inside a functional component it gets redeclared and recomputed each time the FC renders. The re-declaration entices referential inequality and re-computation spends additional resources. The downsides of these two factors is usually not detrimental, but there is a solution for this conundrum as well. The solution comes in the form of the <code>useMemo</code> hook and it&#8217;s specialized version called <code>useCallback</code>. Let&#8217;s first explore the elder of the two siblings.</p>&#10;<h4 id="usememo">useMemo</h4>&#10;<p>As its name suggests, the point of the <code>useMemo</code> hook is to enable <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>, preventing needless recalculation.</p>&#10;<blockquote>&#10;<p>What does this mean exactly ?</p>&#10;</blockquote>&#10;<p>As you might know, every pure function have certain neat properties. Starting with the fact that they always return the same output for a given input. They are just pure data transformations. Based on this, you could create a table of mapping certain inputs to certain outputs, for any input (given that the function is also total - for every input there&#8217;s a well defined output) and any pure function ever. <code>useMemo</code> takes advantage of this property and memoizes the callback. Under the hood, it creates a table of know input and output mapping. If at any point it receives a known input, the input is mapped to an output and returned without the need to invoke the callback.</p>&#10;<p>So pay attention to the mentioned of pure part, even though the signature of <code>useMemo</code> looks similar to <code>useEffect</code> - side effect don&#8217;t belong in <code>useMemo</code><br/>&#10;callbacks. Effectful functions do not exhibit the same properties.</p>&#10;<p>Without further ado, let&#8217;s see what the <code>useMemo</code> hook can offer us.</p>&#10;<iframe src="https://stackblitz.com/edit/react-usememo-example" width="100%" height="500px"/>&#10;<p>The first usage of <code>useMemo</code> is trivial. What&#8217;s more, the first argument passed to <code>useMemo</code> is a callback which when invoked return the ordinal which is the result of casting the text representation of the input&#8217;s value to a number using th <code>Number</code> constructor. It doesn&#8217;t save us much computational resources however it prevents the ordinal constant from being redeclared each time the App renders.</p>&#10;<blockquote>&#10;<p>Is this really worth it?</p>&#10;</blockquote>&#10;<p>That&#8217;s a good question. Since the usage of <code>useMemo</code> impacts readability, I&#8217;d rather not write use it everywhere unless there&#8217;s a fathomable benefit to using it. There are plenty of ways to measure the impact of the <code>useMemo</code> hook and soon we are going to see for ourselves. However, let&#8217;s first get acquitted with the little brother of <code>useMemo</code>.</p>&#10;<h4 id="usecallback">useCallback</h4>&#10;<p>As its name says, <code>useCallback</code> is often used to wrap callbacks. And the docs say a little more about it:</p>&#10;<blockquote>&#10;<p>Pass an inline callback and an array of dependencies. <code>useCallback</code> will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. <code>shouldComponentUpdate</code>).</p>&#10;</blockquote>&#10;<p>At its heart <code>useCallback(fn, deps)</code> is equivalent to <code>useMemo(() =&gt; fn, deps)</code>.</p>&#10;<p>Here&#8217;s an example which you may come across in the wild, debouncing an effectful function which depends on an input value.</p>&#10;<iframe src="https://stackblitz.com/edit/react-usecallback-example" width="100%" height="500px"/>&#10;<p>We aren&#8217;t passing an inline lambda function to <code>useCallback</code> because the return type of higher order <code>debounce</code> function is a function. Higher order function means exactly, a function which also returns a function. This is similar to another familiar concept which we will be discussing called higher order components. Even if you weren&#8217;t sure before, applying the same logic you already know what higher order components are. Back to the debounce example, be careful not to debounce the value setter else the input will appear broken.</p>&#10;<h4 id="usememo-vs-react.memo">useMemo vs React.memo</h4>&#10;<p>It is worth mentioning that <code>useMemo</code> and <code>React.memo</code>, despite having a similar name, have many things in common apart from that. Let&#8217;s look at the signatures of each function, starting with <code>useMemo</code>:</p>&#10;<pre><code class="prism language-tsx">type useMemo = &lt;Value&gt;(callback: () =&gt; Value, dependencies: any[]) =&gt; void&#10;</code></pre>&#10;<p>Compared to <code>React.memo</code>:</p>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;type memo = &lt;Props extends {}&gt;(component: (props: Props) =&gt; React.ReactNode, arePropsEqual: (prevProps, nextProps) =&gt; boolean) =&gt; void&#10;</code></pre>&#10;<p>Firstly, <code>memo</code> doesn&#8217;t accept a dependencies array, but instead accept a function as the second argument. When the function returns true, it signals to React that the props are equal to the previous props by the criteria you establish, and a rerender is unnecessary. Although, the comparison function represent an optional argument, and if it&#8217;s not provided a shallow comparison is performed by React.</p>&#10;<p>And also noticeably, the callback param of <code>useCallback</code> doesn&#8217;t any parameters.Let&#8217;s now spice things up by use <a href="https://npmjs.org/package/rxjs">rxjs</a> to subscribe to a service which return a new value every second. With subscriptions you&#8217;re probably used to unsubscribing in the unmounting phase, from which point on the component instance no longer exists and keeping the subscription running would be a memory leak. This is even suggested by React&#8217;s error message during development, when there&#8217;s an attempt to update the state of a component which has been unmounted.</p>&#10;<h4 id="is-memoization-worth-it">Is memoization worth it</h4>&#10;<p>From my very first contact with the memoization hooks (<code>useMemo</code> and <code>useCallback</code>), I liked the idea of being able to further optimize my code&#8217;s performance. However as we discussed, the usage of the before mentioned hooks comes at the cost of readability. So in order to be able to make quality decisions on whether or not the trade-off is worth it in a given situation, it is essential to know the impact and have proof concrete backing up your decisions. Fortunately, React provides us with a Swiss army knife of tools one of which is the <a href="https://reactjs.org/docs/profiler.html">Profiler</a> component. The <code>Profiler</code> is very powerful and yet very simple to use.</p>&#10;<p>The majority of the complexity related to the <code>Profiler</code> comes down to the <code>onRender</code> callback. It accepts a number of arguments:</p>&#10;<div class="table-wrapper"><table>&#10;<thead>&#10;<tr>&#10;<th>prop</th>&#10;<th>description</th>&#10;</tr>&#10;</thead>&#10;<tbody>&#10;<tr>&#10;<td>id</td>&#10;<td>the &#8220;id&#8221; prop of the Profiler tree that has just committed</td>&#10;</tr>&#10;<tr>&#10;<td>phase</td>&#10;<td>either &#8220;mount&#8221; (if the tree just mounted) or &#8220;update&#8221; (if it re-rendered)</td>&#10;</tr>&#10;<tr>&#10;<td>actualDuration</td>&#10;<td>time spent rendering the committed update</td>&#10;</tr>&#10;<tr>&#10;<td>baseDuration</td>&#10;<td>estimated time to render the entire subtree without memoization</td>&#10;</tr>&#10;<tr>&#10;<td>startTime</td>&#10;<td>when React began rendering this update</td>&#10;</tr>&#10;<tr>&#10;<td>commitTime</td>&#10;<td>when React committed this update</td>&#10;</tr>&#10;<tr>&#10;<td>interactions</td>&#10;<td>the Set of interactions belonging to this update</td>&#10;</tr>&#10;</tbody>&#10;</table>&#10;</div><p>We are going to be focusing on the properties which enable us to determine the effects of <code>useMemo</code>. Firstly, the <code>id</code> is required and its of type string. The string should match the name of the component you rare profiling. It is also required for the component being profiled appear as a child of the respective <code>Profiler</code>. Secondly, the <code>actualDuration</code>. It is going to be the limelight of the experiments. The reason for it is encompassed by the following insert from the docs:</p>&#10;<blockquote>&#10;<p>actualDuration: number - Time spent rendering the Profiler and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. React.memo, useMemo, shouldComponentUpdate). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.</p>&#10;</blockquote>&#10;<iframe src="https://stackblitz.com/edit/react-profiler-example" width="100%" height="500px"/>&#10;<p>This is the setup and experiment which will be performed illustrates the point but is rather simple. Namely, the <code>getFibonacci</code> function is going to enable us to incrementally increase the computational strain on the non-memoized component which will sooner or later stand out compared to the memoized version. What&#8217;s more, the <code>actualDuration</code> of the render for the memoized component should stay roughly the same in the case that we are not updating any dependency of the <code>getFibonacci</code> function (the <code>ordinal</code> to be exact). The <code>getFibonacci</code> function&#8217;s time complexity increases drastically as we increase the ordinal, to the point that after having entered <code>9999</code> I received a stackoverflow error(this was performed on a second generation Ryzen 7 laptop). Since there is a significant jump in complexity with each additional digit the idea is to run benchmarks for a single, double and triple digits. Furthermore, to be able to compare the results we are going to render a non-memoized and a memoized version of the Fibonacci component. By non-memoized I mean a component which calculates the Fibonacci number at a given place based on the supplied ordinal prop. Each time the component renders the computation is going to be performed form the ground up. Whereas the memoized sibling of the component has the computation wrapped in a <code>useMemo</code> hook with a single dependency, the ordinal, which is passed as an argument to the <code>getFibonacci</code> function. On the other hand, we are not going to be running the tests for both component simultaneously since they rely on the same state. Although, every step along the way, including the most insightful growth rate statistic are going to be logged to the console. In this example I specified 50 iterations and based on the profiler data from those 50 iterations an average is induced. Moreover, based on the averages the growth rates are calculated from lower to higher (left to right).</p>&#10;<p>After a couple of runs, in case of the memoized component the growth rates where deviations I observed where around 20%. Although the averages, in case of the memoized component, are expected to be roughly the same, there are divinations and that is normal considering that the <code>actualDuration</code> is a small number. Meaning that the absolute differences are miniscule. On the other hand after having ran the non-memoized version of the component a number of times some distinctions where obvious. Namely, the growth rate from the 9th to the 99th was circa 20% on average. Although as mentioned before this isn&#8217;t a significant amount, however the increase was rather consistent. Moreover, the growth rate from the 99th to the 999th shot up by a more significant margin. Around 300% on average, now that is a more noticeable result.</p>&#10;<p>The conclusion is that&#8217;s probably not necessary to memoize simple expressions and functions unless you are working on a piece of code in the critical path or you require referential integrity to be preserved when working with highly optimized components.</p>&#10;<h2 id="rules-of-hooks">Rules of hooks</h2>&#10;<p>I shall share with you a summary the dedicated section in the official docs, called <a href="https://reactjs.org/docs/hooks-rules.html">Rules of Hooks</a>. Both principles which we are going to discuss revolve around the same requirement and that is to <strong>not</strong> change the order in which the hooks are rendered at any point of the components life cycle. Else undefined behavior is likely to happen. If you&#8217;re interested to find out why, here&#8217;s a great <a href="https://reactjs.org/docs/hooks-rules.html#explanation">example</a>. The first principle says:</p>&#10;<blockquote>&#10;<p><strong>Don&#8217;t call Hooks inside loops, conditions, or nested functions.</strong>  Instead, always use Hooks at the top level of your React function. By following this rule, you ensure that Hooks are called in the same order each time a component renders. That&#8217;s what allows React to correctly preserve the state of Hooks between multiple  <code>useState</code>  and  <code>useEffect</code>  calls.</p>&#10;</blockquote>&#10;<p>It is important to remember that the principles are there to protect you. They may even overprotect you, but up to a point it&#8217;s still better than being under-protecting. An example of an overprotective principle is:</p>&#10;<blockquote>&#10;<p>Don&#8217;t call Hooks inside nested functions</p>&#10;</blockquote>&#10;<p>The point is that it&#8217;s imperative to respect the requirement that hooks are to be called in the same order, from render A to render Z. Invoking hooks inside nested functions does not jeopardizing the requirement, unless you use a loop or a conditional inside it. Heck, even using a loop or conditional statement without breaking the contract. However, in the case of a conditional like an if statement, a hook may not get called during a given render causing other hooks to be rendered out of order. As with loops, like <code>forEach</code>, the length of the array may vary, which entails the same negative effects pertaining to conditionals. To demonstrate the benevolence of hooks inside nested functions I created the following stress test:</p>&#10;<iframe src="https://stackblitz.com/edit/react-hooks-nested-function" width="100%" height="500px"/>&#10;<p>Feel free to experiment yourself.</p>&#10;<blockquote>&#10;<p>Then, why did the React team declare hooks inside nested functions as an anti-pattern?</p>&#10;</blockquote>&#10;<p>It&#8217;s easier to check whether a given piece of code, which uses hooks, is doing something which may upset the hook invocation order if you forbid hooks inside nested functions entirely. On this occasion, the React team was probably cornered and had to make a decision. They chose the safer path, which is understandable. Taking into account React&#8217;s widespread adoption and the fact that bugs introduced by not following the consistent hook order requirement are difficult to debug and reproduce, it&#8217;s safer to have false positives than undetected issues.</p>&#10;<p>Based on the research, it goes without saying, that using hooks in async functions are part of the same, code red, category as loops and conditionals. Because there&#8217;s a high chance that the order in which hooks are invoked is going to change from one render to another.</p>&#10;<p>And the second principle states:</p>&#10;<blockquote>&#10;<p><strong>Don&#8217;t call Hooks from regular JavaScript functions.</strong>  Instead, you can:</p>&#10;</blockquote>&#10;<ul>&#10;<li>&#9989; Call Hooks from React function components.</li>&#10;<li>&#9989; Call Hooks from custom Hooks (we&#8217;ll learn about them  <a href="https://reactjs.org/docs/hooks-custom.html">on the next page</a>).</li>&#10;</ul>&#10;<p>To clarify the point:</p>&#10;<blockquote>&#10;<p>Don&#8217;t call Hooks from regular JavaScript functions</p>&#10;</blockquote>&#10;<p>If a JavaScript function invokes a hooks inside its body. Firstly, you may consider prefixing its name with &#8220;use&#8221;, if that is not already the case. Secondly, and more importantly, the rules of hooks now apply to the function which consumes another hook. Furthermore, if you use the newly created custom hook inside another function, it too becomes a hook inheriting the naming convention and rules. And so on, and so forth.</p>&#10;<p>As for remembering the rules, luckily for us lazy developers who are not fond of learning all the things by heart. Khm, like we had to do at school. The React team created an <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint plugin</a> which encompasses the above mentioned rules and basically teaches your IDE how to point out when you are doing something borderline. Just to see if the <code>useState</code> hook inside a callback is something that you did on purpose or a prank. Unfortunately, the IDE doesn&#8217;t much of a sense of humor.</p>&#10;<p>Finally, remember how we talked about rules of hooks being overprotective at time&#8230; In occasions where the order of hooks is guaranteed between renders and eslint still raises an error or a warning, you may disable the specific rule for the line which is the locus. For arguments sake let&#8217;s that you want to disable a complaint about a hook inside a nested function, in which case you&#8217;d target the <code>react-hooks/rules-of-hooks</code> rule:</p>&#10;<p><code>// eslint-disable-line react-hooks/rules-of-hooks</code><br/>&#10;or<br/>&#10;<code>// eslint-disable-next-line react-hooks/rules-of-hooks</code></p>&#10;<p>One more example where the hooks eslint plugin is being overprotective, which I commonly come across, is the <code>react-hooks/exhaustive-deps</code> rule. So what&#8217;s the eslint rule about. It is pretty straightforward:</p>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;&#10;const Hello: React.FC&lt;{ name, fetchName: () =&gt; void }&gt; = ({ name, fetchName }) =&gt; {&#10;  React.useEffect(() =&gt; {&#10;    fetchName()&#10;  }, [])&#10;  return &lt;div&gt;{name}&lt;/div&gt;&#10;}&#10;</code></pre>&#10;<p>Similarly to the previous example it is a case of a rule sanity check rule. With the assumption that it is more likely that you forgot to declare a dependency, in which case your effect is not going to run as often as it may should, depending on the use case. Compared to the scenario where you purposefully didn&#8217;t declare a dependency because you want a certain function to be invoked only once, when the component has been mounted. Same as before, you may suppress the warning like so:</p>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;&#10;const Hello: React.FC&lt;{ name, fetchName: () =&gt; void }&gt; = ({ name, fetchName }) =&gt; {&#10;  React.useEffect(() =&gt; {&#10;    fetchName()&#10;  }, []) // eslint-disable-line react-hooks/exhaustive-deps&#10;  return &lt;div&gt;{name}&lt;/div&gt;&#10;}&#10;</code></pre>&#10;<h2 id="usedebugvalue">useDebugValue</h2>&#10;<p>The last among the hooks, is the <code>useDebugValue</code> hook. I only recently found out about the hook, blessed be intellisense, and my reaction was along the lines of:</p>&#10;<p>&#8220;Wait there&#8217;s a hook called <code>useDebugValue</code>, that sounds intriguing, so what does it do?&#8221;</p>&#10;<blockquote>&#10;<p><code>useDebugValue</code> can be used to display a label for custom hooks in React DevTools.</p>&#10;</blockquote>&#10;<p>&#8220;I love React DevTools, this must a really great addition to my hooks arsenal! Let&#8217;s test it out. Okay, I&#8217;ve created a custom hook. It&#8217;s named <code>useValue</code>, so its label in DevTools should be equivalent to Value.&#8221;</p>&#10;<p>&#8220;It is, alright! That wasn&#8217;t difficult.&#8221;</p>&#10;<p>&#8220;Just a second. This means that the default label is <code>useValue</code>, let me test it.&#8221;</p>&#10;<p>*Comments out useDebug invocation*</p>&#10;<p>&#8220;Hmmm, the DevTools still show <code>Value</code>. It must be an issue with hot reloading. Let me refresh the page. It&#8217;s still the same&#8230; Let me make sure that I correctly saved the file. It&#8217;s still the same. And what about the commented out hook - nothings out of the ordinary.&#8221;</p>&#10;<p>So I can to the conclusion that with version <code>4.6.0</code> of React DevTools it is no longer necessary to use the <code>useDebugValue</code> hook since the name of the hook will be properly formatted and used as the label. However, there still may be a use case for the <code>useDebugValue</code> hook and it has to do with the second parameter the hook accepts. There are no mentions of this parameter in the docs, luckily for use the <a href="https://npmjs.org/package/@types/react">typings for react</a> provides more insight.</p>&#10;<blockquote>&#10;<p>What&#8217;s the point of the second parameter?</p>&#10;</blockquote>&#10;<p>It&#8217;s simple - it&#8217;s named format and it does exactly that. it&#8217;s signature depends on the first argument which is the value returned by the hook, meaning that if the value were a string the type signature of the format function would be <code>format: (value: string) =&gt; any</code>. Albeit useful, the ability to format the value is not something which you would use consistently. What&#8217;s more, in the case of the <code>useValue</code> hook applying any formatting like upper-casing or lower-casing the value would just be confusing. Nevertheless, the formatting may play a bigger role when the return type of the hook is a complex object.</p>&#10;<p>Enough storytelling, let&#8217;s get our beaks wet by writing our first custom hook! Event though the <code>useDebugValue</code> hook is less exciting, writing custom hooks is a thrill.</p>&#10;<iframe src="https://stackblitz.com/edit/react-usedebugvalue" width="100%" height="500px"/>&#10;<p>Notice the usage of the <code>useCallback</code> hook, when writing hooks, which are reusable, especially as a library author, you may want to pay special attention to writing efficient code in every sense of the word. Make the consumers of your custom hook look up to you in quality. Importantly, however, nobody writes perfect code from the get go, unless they have written a similar program before, furthermore a custom hook is useless if it doesn&#8217;t work correctly. Hence, make sure that your custom hooks work before refactoring your code to increase it&#8217;s quality.</p>&#10;<p>A word which often goes hand to hand with the word refactoring is the word <code>TDD</code> and <code>writing test</code>. Just as it is difficult to write high quality efficient code in a single iteration, it is also difficult to refactor your code without first having written the the tests for it. Ask uncle Bob if you don&#8217;t believe me. No, seriously check out one of his videos on the topic of <a href="https://www.youtube.com/watch?v=qkblc5WRn-U">TDD</a>.</p>&#10;<p>Now that I&#8217;ve talked about writing custom hooks and writing test in the same sentence, I&#8217;ve probably left you wondering how to test custom hooks and some of you may also wonder how to test your components which consume React hooks or custom hooks. I didn&#8217;t plan to include this section in the course but I&#8217;ll make sure to leave room for it. So be on the lookout in of of the future section.</p>&#10;<h2 id="creating-your-own-hooks">Creating your own hooks</h2>&#10;<p>Now that we have mastered the basics we are able to move onto more advanced topics. Imagine yourself as the painter who has acquired all the necessary colors on his or her palette and is ready to paint a masterpiece.</p>&#10;<h3 id="implementing-redux-with-usecontext-and-usereducer">Implementing redux with useContext and useReducer</h3>&#10;<p>Are you used to having a global immutable data store which serves as your app single source of truth?<br/>&#10;I am too! So let&#8217;s implement a basic version of redux using just 2 hooks that we mentioned before.</p>&#10;<h3 id="usefetch">useFetch</h3>&#10;<p>useState and useEffect</p>&#10;<h3 id="usepagination">usePagination</h3>&#10;<p>It&#8217;s getting ever more exiting! In the next section we are going to built upon the example from the previous section, however not only that. We are also going to take the idea one step further by implementing pagination.</p>&#10;<p>useState and useEffect and IntersectionObserver API</p>&#10;<p>Check out <a href="https://npmjs.org/package/react-query">react-query</a> and/or <a href="https://npmjs.org/package/swr">swr</a> and react-window and/or react-virtualized</p>&#10;<h3 id="going-up-a-notch-with-middleware">Going up a notch with middleware</h3>&#10;<p>Now we are shifting into the fifth gear when.</p>&#10;<p>If you haven&#8217;t done so already check out <a href="https://npmjs.org/package/redux-thunk">redux-thunk</a> and <a href="https://npmjs.org/package/redux-thunk">redux-observable</a></p>&#10;<p>You may have noticed that this approach conflicts with relying on a hook similar to <code>useFetch</code>. I&#8217;ve been a proponent of using <code>redux-observable</code> for long time now, because performing side effects like network requests in epics, using <a href="https://npmjs.org/package/rxjs">rxjs</a> gives you a lot of freedom. You are able to denounce, throttle, cancel requests and more.</p>&#10;<p>However, more recently, I&#8217;ve been looking into relying on libraries like <code>react-query</code> to handle &#8220;server state&#8221; related matters. There are many carefully though out mechanisms which are at your services, out of the box, when using both <code>react-query</code> and <code>swr</code>. Let&#8217;s go over the major concepts, which although possible to implement solely using redux-observable and rxjs, require quite a bit of additional effort.</p>&#10;<p>However, I&#8217;ve considered creating a library which would bridge that gap for <code>redux-observable</code>. If you are aware of something similar which already fulfills such a role, pray let me know.</p>&#10;<h3 id="angular-like-services-and-dependency-injection">Angular like services and dependency injection</h3>&#10;<p>Imagine that you are building an app which is using JWT based authentication. The JWT has to be stored on the client after the user logs in. However, we cannot store the token as part of the global state or any component state for that matter because both concepts are tied to individual sessions. Meaning that once the user closes the tab in which your app once resided, the information about the token is gone. In case that the token has not yet expired, it would be inefficient to ask the user to log in once they return to the app. We can provide a better user experience by storing the token in a place which persists through sessions and let the server decide when a token has expired and it&#8217;s time to reauthenticate. Luckily for us there are many options to choose from which fit this description however a popular option is to use the <code>localStorage</code> API.</p>&#10;<p><code>useState</code> and <code>useEffect</code></p>&#10;<h2 id="testing-custom-hooks">Testing custom hooks</h2>&#10;<p>TODO</p>&#10;<h3 id="testing-components-which-use-custom-hooks">Testing components which use custom hooks</h3>&#10;<p>TODO</p>&#10;<h2 id="hooks-vs-hocs">Hooks vs HOC&#8217;s</h2>&#10;<p>You can read about what the creator of <a href="https://github.com/acdlite/recompose">recompose</a>, the de facto React HOC&#8217;s library, had say about hooks at the top of the repository&#8217;s README file. However, in a nutshell, React is heading towards hooks and recompose is no longer actively maintained.</p>&#10;<h3 id="pros-of-hooks">Pros of hooks</h3>&#10;<ul>&#10;<li>Easier and faster to set up. Take the example of selecting a value from the redux store:</li>&#10;</ul>&#10;<h4 id="selecting-a-value-from-the-state-with-hocs">Selecting a value from the state with HOC&#8217;s</h4>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;import { connect } from 'react-redux'&#10;import { State, selectName } from '../store'&#10;&#10;const Hello: React.FC&lt;{ name: string }&gt; = ({ name }) =&gt; (&#10;  &lt;div&gt;Hello {name}&lt;/div&gt;&#10;)&#10;&#10;export const HelloContainer = connect((state: State) =&gt; ({&#10;  name: selectName(state)&#10;}))(Hello)&#10;</code></pre>&#10;<h4 id="selecting-a-value-from-state-with-hooks">Selecting a value from state with hooks</h4>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;import { useSelector } from 'react-redux'&#10;import { State, selectName } from '../store'&#10;&#10;const Hello: React.FC = ({ name }) =&gt; {&#10;  const name = useSelector(selectName)&#10;  return (&#10;    &lt;div&gt;Hello {name}&lt;/div&gt;&#10;  )&#10;}&#10;</code></pre>&#10;<h3 id="cons-of-hooks">Cons of hooks</h3>&#10;<ul>&#10;<li>Hooks are more difficult to reuse if you want to keep a clear separation between container and presentation components. Let&#8217;s revisit the previous example</li>&#10;</ul>&#10;<h4 id="create-multiple-components-with-a-single-hoc">Create multiple components with a single HOC</h4>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;import { connect } from 'react-redux'&#10;import { State, selectName } from '../store'&#10;import { Hello } from './Hello'&#10;import { Hello1 } from './Hello1'&#10;&#10;const connectWithName = connect((state: State) =&gt; ({&#10;  name: selectName(state)&#10;}))&#10;&#10;export const HelloContainer = connectWithName(Hello)&#10;&#10;export const Hello1Container = connectWithName(Hello1)&#10;</code></pre>&#10;<p>Notice that we didn&#8217;t even import <code>React</code> in the example above. Because there is no need to, since importing <code>React</code> is only required your file contains <code>JSX</code> or <code>TSX</code>. What&#8217;s more, the file extension may be shortened from <code>tsx</code> to <code>ts</code>.</p>&#10;<h4 id="create-multiple-components-with-a-single-hook">Create multiple components with a single hook</h4>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;import { connect } from 'react-redux'&#10;import { State, selectName } from '../store'&#10;import { Hello } from './Hello'&#10;import { Hello1 } from './Hello1'&#10;&#10;export const HelloContainer = () =&gt; {&#10;  const name = useSelector(selectName)&#10;  return &lt;Hello name={name} /&gt;&#10;}&#10;&#10;export const Hello1Container = () =&gt; {&#10;  const name = useSelector(selectName)&#10;  return &lt;Hello1 /&gt;&#10;}&#10;</code></pre>&#10;<p>Code-wise there&#8217;s not much of a difference, however if we take a more holistic approach the point becomes more obvious. Not seldom, will you want inject a certain prop or props and spread the rest.</p>&#10;<h4 id="create-multiple-components-with-a-single-hoc-2">Create multiple components with a single HOC 2</h4>&#10;<pre><code class="prism language-tsx">import { connect } from 'react-redux'&#10;import { State, selectName } from '../store'&#10;import { Dashboard } from './Dashboard'&#10;import { Sidebar } from './Sidebar'&#10;&#10;const connectWithName = connect((state: State) =&gt; ({&#10;  name: selectName(state)&#10;}))&#10;&#10;export const DashboardContainer = connectWithName(Dashboard)&#10;&#10;export const SidebarContainer = connectWithName(Sidebar)&#10;</code></pre>&#10;<p>The above example has the exact same structure as before.</p>&#10;<h4 id="create-multiple-components-with-a-single-hook-2">Create multiple components with a single hook 2</h4>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;import { connect } from 'react-redux'&#10;import { State, selectName } from '../store'&#10;import { Dashboard } from './Dashboard'&#10;import { Sidebar } from './Sidebar'&#10;&#10;export const DashboardContainer = (props: Omit&lt;React.ComponentProps&lt;typeof Dashboard&gt;, 'name'&gt;) =&gt; {&#10;  const name = useSelector(selectName)&#10;  return &lt;Dashboard {...props} name={name} /&gt;&#10;}&#10;&#10;export const SidebarContainer = (props: Omit&lt;React.ComponentProps&lt;typeof Sidebar&gt;, 'name'&gt;) =&gt; {&#10;  const name = useSelector(selectName)&#10;  return &lt;Sidebar {...props} name={name} /&gt;&#10;}&#10;</code></pre>&#10;<p>Now the difference is more obvious. There&#8217;s some boilerplate which is repeated from one case to another. Nevertheless, we already know how to easily abstract away such boilerplate code. Yes, we can create a higher order component which utilizes a hooks or hooks inside it&#8217;s body. In the case of <code>react-redux</code> you may simply reach for the <code>connect</code> HOC. What&#8217;s more, creating a HOC which utilizes a custom hook is trivial.</p>&#10;<pre><code class="prism language-tsx">import React from 'react'&#10;import { Sidebar } from './Sidebar'&#10;&#10;export const withModal = &lt;Props extends {}&gt;(Component: React.ComponentType&lt;Props&gt;) =&gt; {&#10;  const ComponentWithModal = (props: Omit&lt;React.ComponentProps&lt;typeof Dashboard&gt;, 'isModalOpen' | 'toggleOpenModal'&gt;) =&gt; {&#10;    const modal = React.useContext(ModalContext)&#10;    return &lt;Component {...props} isModalOpen={modal.isOpen} toggleOpenModal={modal.toggleOpen} /&gt;&#10;  }&#10;  ComponentWithModal.displayName = `withModal(${Component.displayName || Component.name})`&#10;  return ComponentWithModal&#10;}&#10;&#10;export const SidebarContainer = withModal(Sidebar)&#10;</code></pre>&#10;<p>The part where we a assign a <code>displayName</code> to the new component is optional, However, it aids debugging through the usage of <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React DevTools</a></p>&#10;<p>Observing things from this perspective, HOC&#8217;s and hooks can coexist with each other in a state of harmony.</p>&#10;<blockquote>&#10;<p>But, why bother writing pure components?</p>&#10;</blockquote>&#10;<p>First of all, you can easily instantiate the component with randomly generated props with the help of a library like <a href="https://nomjs.org/package/faker">faker</a>.</p>&#10;<p>Moreover, many benefits are derived from the above fact.</p>&#10;<p>Firstly your component is easy to unit test using <a href="https://npmjs.org/package/@testing-library/react">react testing library</a> or <a href="https://npmjs.org/package/enzyme">enzyme</a>.</p>&#10;<p>Secondly, you can easily reuse a pure component across projects by publishing it using a tool like <a href="https://npmjs.org/package/@bit/cli">bit</a></p>&#10;<p>Thirdly, you may effortless develop and display your components in <a href="https://npmjs.org/package/@storybook/react">storybook</a> or a similar environment etc.</p>&#10;<p>As a side note, you can still test an impure component which consumes a hook, without actually performing any side effects like network calls by mocking the function. For example, using <a href="https://jestjs.io/docs/en/mock-functions.html">jest</a>.</p>&#10;<p>Before we cover the next section, which is really important, let&#8217;s first glance over the following terms.</p>&#10;<p><a href="https://en.m.wikipedia.org/wiki/Serialization">Serializable</a> - A message is serializeable if it can be stringified to JSON - which is not possible in the case of recursive structures.</p>&#10;<p><a href="https://en.m.wikipedia.org/wiki/Command%E2%80%93query_separation">CQRS</a> - Command Query Responsibility Segregation, states that every method should either be a command that performs an action, or a query that returns data to the caller, but not both.</p>&#10;<p>There is, however, a third approach inspired by microservices. Namely, if you think redux as a message broker and your components as services. In a nutshell, the main selling point of a microservice architecture is that it enables you to keep your services decoupled. For example service A, which depends on service B, doesn&#8217;t have to know how to communicate with service B directly. Else if service B were to be replaced with service C which behaves completely the same as B, despite the fact, service A would have to be altered. Namely, the reference which A holds to B would have to be replaced with a reference to C. A message broker solves this issue by having the individual service dispatch messages which are usually serializeable. The message broker is now responsible for passing the messages between services and the services themselves just have to know which actions they want to listen to and dispatch. You may have noticed that we haven&#8217;t entirely decoupled our services from the rest of the world (else the service would turn into a pure function), we just narrowed down it&#8217;s dependencies to a minimum. The only reference the services have to hold is a reference to the message broker. Specifically how to read and write (select and dispatch actions). Following the principles of CQRS it is preferable to keep these two operations separate. Fortunately, the message broker is not something which is often replaced. Even if it did, due to the fundamental simplicity of a message broker, the upgrade would be large scale but not very complicated. This means that it could be automated.</p>&#10;<p>In conclusion, hooks are a great addition to the react ecosystem and there are plenty of use cases for hooks. Similarly to HOC&#8217;s hooks may encapsulate logic and/or side effects and keep out code DRY. On top of that, hooks can be used inside the body of functional component. Taking that into consideration, never again do you have to write a class component. Currently, however, with the notable exception of error boundaries. For more information about this limitation, check out <a href="https://overreacted.io/why-isnt-x-a-hook/">why is X not a hook?</a>.</p>&#10;<h2 id="migrating-common-libraries-to-hooks">Migrating common libraries to hooks</h2>&#10;<p>All of the major react libraries, which have previously relied on HOC&#8217;s, have migrated or are in the of migrating to hooks.</p>&#10;<blockquote>&#10;<p>But does this mean that I have to relearn every single one of them.</p>&#10;</blockquote>&#10;<p>The short answer is no. There may be some differences here and there, but having come this far into the course, you are absolutely equipped for tackling such migrations. Nevertheless, in this section we are going to cover some of the most prevalent cases and what better way is there to kick off this section than to talk about the react integration of redux. Give it up for <code>react-redux</code>.</p>&#10;<h3 id="react-redux">react-redux</h3>&#10;<p>I bet that you&#8217;ll rarely ever want to connect another component using the higher order component API after you&#8217;ve got a taste for the the hooks <code>react-redux</code> has to offer.</p>&#10;<p><code>connect</code></p>&#10;<p>TODO</p>&#10;<p><code>useSelector</code></p>&#10;<p>TODO</p>&#10;<p><code>useDispatch</code></p>&#10;<p>Reading this section left a bad aftertaste and if you&#8217;re like me, the immediate though that crossed my mind was: &#8220;Lemme implement the <code>useActions</code> hook.&#8221; I&#8217;ll let you in on a secret. Once I implemented the <code>useActions</code> I never looked back. So as an added bonus I&#8217;ll show you to implement the <code>useActions</code> in a type safe manner.</p>&#10;<p><code>useActions</code></p>&#10;<p>TODO</p>&#10;<h3 id="react-router">react-router</h3>&#10;<p><code>withRouter</code></p>&#10;<p>TODO</p>&#10;<p><code>useHistory</code></p>&#10;<p>TODO</p>&#10;<p><code>useParams</code></p>&#10;<p>TODO</p>&#10;<p><code>useRouter</code></p>&#10;<p>TODO</p>&#10;<h3 id="material-ui">material-ui</h3>&#10;<p>Material UI is using <a href="https://npmjs.org/package/jss">jss</a> under the hood and exposes a similar API compared to <a href="https://npmjs.org/package/react-jss">react-jss</a> hence if you learn one you have learned the other the a significant extent safe for certain caveats.</p>&#10;<p><code>makeStyle</code></p>&#10;<blockquote>&#10;<p>This is too easy.</p>&#10;</blockquote>&#10;<p>I agree. So for the next section let&#8217;s do something more difficult by implementing a prop based animation. In order to make this work we are going to overcome a few hurdles along the way, but have faith.</p>&#10;<h3 id="xstate">xstate</h3>&#10;<p>TODO</p>&#10;<h3 id="styled-components">styled-components</h3>&#10;<p>TODO</p>&#10;<h3 id="react-spring">react-spring</h3>&#10;<p>TODO</p>&#10;<h2 id="parting-message">Parting message</h2>&#10;<p>Continue to learn and explore. Don&#8217;t be afraid to dig into documentation, but never stop practicing. And the sky is the limit for you.</p>&#10;</iframe>
          </div>
        </div>

        <div class="disqus__wrapper">
          <div id="disqus_thread"></div>
        </div>
      </main>
    </section>

    <script src="./index.js"></script>

    <script>
      /*
      (function () { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://mateja176-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
      */
    </script>
    <!--
    <script id="dsq-count-scr" src="//mateja176-blog.disqus.com/count.js" async></script>
	-->
	
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137872597-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'UA-137872597-1');
    </script>
  </body>

</html>

