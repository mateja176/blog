<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Hooks Course</title>
    <base href="./react-hooks-course.html" />
    <link rel="stylesheet" href="https://stackedit.io/style.css" />
    <link rel="stylesheet" href="./index.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon" />

    <meta
      property="og:url"
      content="https://mateja176.github.io/blog/react-hooks-course.html"
    />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="React Hooks Course" />
    <meta
      property="og:description"
      content="Read full article at https://mateja176.github.com/blog/react-hooks-course.html"
    />
    <meta property="og:image" content="https://i.imgur.com/nw1YiXw.png" />
    <meta property="og:image:width" content="125" />
    <meta property="og:image:height" content="125" />

    <meta name="twitter:card" content="summary" />
    <meta
      name="twitter:site"
      content="https://mateja176.github.io/blog/react-hooks-course.html"
    />
    <meta name="twitter:title" content="React Hooks Course" />
    <meta
      name="twitter:description"
      content="Read full article at https://mateja176.github.com/blog/react-hooks-course.html"
    />
    <meta name="twitter:image" content="https://i.imgur.com/nw1YiXw.png" />
  </head>

  <body class="stackedit">
    <section>
      <div class="toc__toggle" tabindex="0">
        <i class="material-icons">toc</i>
      </div>

      <div class="stackedit__left app-hidden">
        <div class="stackedit__toc">
          <ul>
            <li>
              <a href="#react-hooks-course">React Hooks Course</a>
              <ul>
                <li><a href="#table-of-contents">Table of contents</a></li>
                <li><a href="#motivation">Motivation</a></li>
                <li>
                  <a
                    href="#translating-class-patterns-to-functional-components-with-hooks"
                    >Translating class patterns to functional components with
                    hooks</a
                  >
                </li>
                <li><a href="#rules-of-hooks">Rules of hooks</a></li>
                <li><a href="#usedebugvalue">useDebugValue</a></li>
                <li>
                  <a href="#creating-your-own-hooks">Creating your own hooks</a>
                </li>
                <li>
                  <a href="#testing-custom-hooks">Testing custom hooks</a>
                </li>
                <li><a href="#hooks-vs-hocs">Hooks vs HOC’s</a></li>
                <li>
                  <a href="#migrating-common-libraries-to-hooks"
                    >Migrating common libraries to hooks</a
                  >
                </li>
                <li><a href="#parting-message">Parting message</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>

      <main>
        <div class="stackedit__right">
          <div class="stackedit__html">
            <h1 id="react-hooks-course">React Hooks Course</h1>
            <h2 id="table-of-contents">Table of contents</h2>
            <ul>
              <li>
                <a href="#react-hooks-course">React Hooks Course</a>
                <ul>
                  <li><a href="#table-of-contents">Table of contents</a></li>
                  <li><a href="#motivation">Motivation</a></li>
                  <li>
                    <a
                      href="#translating-class-patterns-to-functional-components-with-hooks"
                      >Translating class patterns to functional components with
                      hooks</a
                    >
                    <ul>
                      <li>
                        <a href="#state-management">State management</a>
                        <ul>
                          <li><a href="#setstate">setState</a></li>
                          <li><a href="#usestate">useState</a></li>
                          <li>
                            <a href="#multiple-state-fields-with-setstate"
                              >Multiple state fields with setState</a
                            >
                          </li>
                          <li>
                            <a href="#multiple-state-fields-with-usestate"
                              >Multiple state fields with useState</a
                            >
                          </li>
                          <li><a href="#async-setstate">Async setState</a></li>
                          <li><a href="#async-usestate">Async useState</a></li>
                        </ul>
                      </li>
                      <li>
                        <a href="#reduced-pattern">Reduced pattern</a>
                        <ul>
                          <li><a href="#usereducer">useReducer</a></li>
                          <li>
                            <a href="#reducer-pattern-with-class-components"
                              >Reducer pattern with class components</a
                            >
                          </li>
                          <li>
                            <a href="#usereducer-hook">useReducer hook</a>
                          </li>
                          <li>
                            <a href="#usereducer-with-reset"
                              >useReducer with reset</a
                            >
                          </li>
                        </ul>
                      </li>
                      <li>
                        <a href="#react-context-and-hooks"
                          >React Context and Hooks</a
                        >
                        <ul>
                          <li>
                            <a href="#componentcontexttype"
                              >Component.contextType</a
                            >
                          </li>
                          <li>
                            <a href="#contextconsumer">Context.Consumer</a>
                          </li>
                          <li><a href="#usecontext">useContext</a></li>
                        </ul>
                      </li>
                      <li>
                        <a href="#ref-pattern">Ref pattern</a>
                        <ul>
                          <li>
                            <a href="#mutable-class-properties"
                              >Mutable class properties</a
                            >
                          </li>
                          <li>
                            <a href="#accessing-dom-node-references"
                              >Accessing DOM node references</a
                            >
                          </li>
                          <li>
                            <a href="#accessing-a-class-component-instance"
                              >Accessing a class component instance</a
                            >
                          </li>
                          <li><a href="#createref">createRef</a></li>
                          <li>
                            <a href="#refs-and-functional-components"
                              >Refs and functional components</a
                            >
                          </li>
                          <li><a href="#useref">useRef</a></li>
                          <li>
                            <a href="#useimperativehandle"
                              >useImperativeHandle</a
                            >
                          </li>
                        </ul>
                      </li>
                      <li>
                        <a href="#lifecycle-methods">Lifecycle methods</a>
                        <ul>
                          <li>
                            <a href="#componentdidmount">componentDidMount</a>
                          </li>
                          <li>
                            <a href="#useeffect-on-mount">useEffect on mount</a>
                          </li>
                          <li>
                            <a href="#componentwillunmount"
                              >componentWillUnmount</a
                            >
                          </li>
                          <li>
                            <a href="#useeffect-will-unmount"
                              >useEffect will unmount</a
                            >
                          </li>
                          <li>
                            <a href="#componentdidupdate">componentDidUpdate</a>
                          </li>
                          <li>
                            <a href="#useeffect-did-update"
                              >useEffect did update</a
                            >
                          </li>
                          <li>
                            <a href="#the-why-of-dependencies"
                              >The why of dependencies</a
                            >
                          </li>
                          <li>
                            <a href="#uselayouteffect">useLayoutEffect</a>
                          </li>
                        </ul>
                      </li>
                      <li>
                        <a href="#properties-and-methods"
                          >Properties and methods</a
                        >
                        <ul>
                          <li><a href="#usememo">useMemo</a></li>
                          <li><a href="#usecallback">useCallback</a></li>
                          <li>
                            <a href="#usememo-vs-reactmemo"
                              >useMemo vs React.memo</a
                            >
                          </li>
                          <li>
                            <a href="#is-memoization-worth-it"
                              >Is memoization worth it</a
                            >
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li><a href="#rules-of-hooks">Rules of hooks</a></li>
                  <li><a href="#usedebugvalue">useDebugValue</a></li>
                  <li>
                    <a href="#creating-your-own-hooks"
                      >Creating your own hooks</a
                    >
                    <ul>
                      <li>
                        <a
                          href="#implementing-redux-with-usecontext-and-usereducer"
                          >Implementing redux with useContext and useReducer</a
                        >
                      </li>
                      <li><a href="#usefetch">useFetch</a></li>
                      <li><a href="#usepagination">usePagination</a></li>
                      <li>
                        <a href="#going-up-a-notch-with-middleware"
                          >Going up a notch with middleware</a
                        >
                      </li>
                      <li>
                        <a
                          href="#angular-like-services-and-dependency-injection"
                          >Angular like services and dependency injection</a
                        >
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="#testing-custom-hooks">Testing custom hooks</a>
                    <ul>
                      <li>
                        <a href="#testing-components-which-use-custom-hooks"
                          >Testing components which use custom hooks</a
                        >
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="#hooks-vs-hocs">Hooks vs HOC’s</a>
                    <ul>
                      <li>
                        <a href="#pros-of-hooks">Pros of hooks</a>
                        <ul>
                          <li>
                            <a
                              href="#selecting-a-value-from-the-state-with-hocs"
                              >Selecting a value from the state with HOC’s</a
                            >
                          </li>
                          <li>
                            <a href="#selecting-a-value-from-state-with-hooks"
                              >Selecting a value from state with hooks</a
                            >
                          </li>
                        </ul>
                      </li>
                      <li>
                        <a href="#cons-of-hooks">Cons of hooks</a>
                        <ul>
                          <li>
                            <a
                              href="#create-multiple-components-with-a-single-hoc"
                              >Create multiple components with a single HOC</a
                            >
                          </li>
                          <li>
                            <a
                              href="#create-multiple-components-with-a-single-hook"
                              >Create multiple components with a single hook</a
                            >
                          </li>
                          <li>
                            <a
                              href="#create-multiple-components-with-a-single-hoc-2"
                              >Create multiple components with a single HOC 2</a
                            >
                          </li>
                          <li>
                            <a
                              href="#create-multiple-components-with-a-single-hook-2"
                              >Create multiple components with a single hook
                              2</a
                            >
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="#migrating-common-libraries-to-hooks"
                      >Migrating common libraries to hooks</a
                    >
                    <ul>
                      <li><a href="#react-redux">react-redux</a></li>
                      <li><a href="#react-router">react-router</a></li>
                      <li><a href="#material-ui">material-ui</a></li>
                      <li><a href="#xstate">xstate</a></li>
                      <li>
                        <a href="#styled-components">styled-components</a>
                      </li>
                      <li><a href="#react-spring">react-spring</a></li>
                    </ul>
                  </li>
                  <li><a href="#parting-message">Parting message</a></li>
                </ul>
              </li>
            </ul>
            <p>
              To be able to get the most out of this course it’s best if you are
              already familiar with JavaScript, React and Typescript, although
              not necessary to follow along, is strongly recommended.
            </p>
            <h2 id="motivation">Motivation</h2>
            <p>In the words of the creators:</p>
            <ul>
              <li>It’s hard to reuse stateful logic between components</li>
              <li>Complex components become hard to understand</li>
              <li>Classes confuse both people and machines</li>
            </ul>
            <p>
              If you want to read up on the “why” of hooks you may do so by
              following
              <a href="https://reactjs.org/docs/hooks-intro.html#motivation"
                >this</a
              >
              link.
            </p>
            <p>
              There’s even an
              <a href="https://youtu.be/dpw9EHDh2bM">introductory video</a> on
              hooks by Dam Abramov
            </p>
            <h2
              id="translating-class-patterns-to-functional-components-with-hooks"
            >
              Translating class patterns to functional components with hooks
            </h2>
            <h3 id="state-management">State management</h3>
            <h4 id="setstate">setState</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-setstate-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <h4 id="usestate">useState</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usestate-demo&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              We immediately notice that the example relying on
              <code>useState</code> is slimmer. For example, we didn’t have to
              declare the type of the name state since it was inferred based on
              the initial value which was once again <code>''</code>. We invoked
              <code>setName</code> with the new value for the name state instead
              of passing it an object.
            </p>
            <p>
              However, there are a few things to note here. When
              <code>setName</code> is invoked the
              <code>HelloContainer</code> component is rerendered with the value
              passed to the setter. This means that even if
              <code>initialValue</code> had changed by the time of the rerender,
              it would not affect the name state.
            </p>
            <p>
              Wait a second, I got a call from the product owner. He said that
              the new requirement is that the greeting rendered by the
              <code>Hello</code> component should not change immediately as the
              user is typing into the input, but should instead update only when
              the user submits the update. Fear not, once again we can tackle
              the challenge using the <code>useState</code> hook. Let’s delve
              deeper into exploration by answering the question of how to handle
              multiple state fields.
            </p>
            <h4 id="multiple-state-fields-with-setstate">
              Multiple state fields with setState
            </h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-setstate-mutiple&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <h4 id="multiple-state-fields-with-usestate">
              Multiple state fields with useState
            </h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usestate-mutiple&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              This was fairly easy. However, you might ask: Why did we have to
              add another <code>useState</code> hook. This brings us to another
              notable difference. Namely, the <code>useState</code> setter does
              not merge the argument with the rest of the state. Meaning that
              you would have to spread the current state in order to perform a
              partial update. Hence it is generally recommended to combine your
              state fields into an object if they are being set simultaneously.
            </p>
            <p>
              Wait, it’s the product owner again. The new business rule states
              that greeting should only update a second after the user
              submitted. And on top of that, if the user updates the value
              during the second after submitting, the name should be updated
              with the most recent value. This sounds complicated, but it is in
              fact easy to implement! Similarly to <code>setState</code>, the
              setter function which is the second element of the array returned
              by the <code>useState</code> also accepts a callback function
              which guaranteed to be invoked with the latest value. Enough of
              the talk.
            </p>
            <h4 id="async-setstate">Async setState</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-async-setstate&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <h4 id="async-usestate">Async useState</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-async-usestate&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              Notice that we invoked <code>setName</code> inside the callback
              passed to <code>setValue</code>. The alternative would have been
              to combine the two state fields into an single object. However,
              this would mean that in order to update either
              <code>value</code> or <code>name</code>, we would have to spread
              the current state along with providing a new value for the given
              field. But wait, it’s not the product owner this time, instead it
              is a colleague from the development team.
            </p>
            <blockquote>
              <p>
                What if the state update logic becomes complex or the state
                involves multiple sub-values? Is this the point where we reach
                for redux?
              </p>
            </blockquote>
            <p>
              I’m glad you asked my friend, and the answer is no, not
              necessarily. Let’s consider the following hook which is a close
              cousin to the <code>useState</code> hook in the next section.
            </p>
            <h3 id="reduced-pattern">Reduced pattern</h3>
            <h4 id="usereducer">useReducer</h4>
            <p>
              As mentioned above and as it is said in the official
              <a href="https://reactjs.org/docs/hooks-reference.html#usereducer"
                >docs</a
              >:
            </p>
            <blockquote>
              <p>
                <code>useReducer</code> is usually preferable to
                <code>useState</code> when you have complex state logic that
                involves multiple sub-values or when the next state depends on
                the previous one.<br />
                <code>useReducer</code> also lets you optimize performance for
                components that trigger deep updates because
                <a
                  href="https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down"
                  >you can pass <code>dispatch</code> down instead of
                  callbacks</a
                >.
              </p>
            </blockquote>
            <p>
              Now, this pattern is not something which was carried over from the
              class component pattern, however we can still implement it using
              class components. And below is an example of what a possible
              implementation may look like.
            </p>
            <h4 id="reducer-pattern-with-class-components">
              Reducer pattern with class components
            </h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-reducer-pattern&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              The above approach is quite verbose however is more scalable. Now
              let’s pay a visit to the man of the hour, low and behold the
              <code>useReducer</code> hook.
            </p>
            <h4 id="usereducer-hook">useReducer hook</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usereducer-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              First of all, you may have noticed that the
              <code>reducer</code> function is declared outside out the
              component and as such it is not coupled to the component. This
              means that the logic for updating the state is replaced and reused
              in other places, it is effectively abstracted away from the
              component. On top that, the update logic is easier to maintain,
              since adding and updating of individual cases is straightforward.
              However, there’s more to it as we will discuss in the
              <strong>Creating your own hooks</strong> section. In a nutshell,
              our reducer is a pure function. Hence the missing puzzle piece is
              the ability to perform side effects. Luckily for us the redux
              architecture is easily extensible with
              <a href="https://redux.js.org/glossary#middlewareh">middleware</a
              >. In the case of the <code>useReducer</code> hook, we can create
              quasi
              <a href="https://www.npmjs.com/package/redux-thunk">thunks</a> and
              <a href="https://redux-observable.js.org/docs/basics/Epics.html"
                >epics</a
              >
              and more. Let’s first complete our tour of available React hooks.
              With a very powerful effectful pattern.
            </p>
            <h4 id="usereducer-with-reset">useReducer with reset</h4>
            <p>
              As an added bonus, let’s go through an example of how to reset the
              reducer state.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usereducer-with-reset&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>It’s nothing too crazy.</p>
            <h3 id="react-context-and-hooks">React Context and Hooks</h3>
            <p>
              If <code>useReducer</code> impressed you just wait until you see
              the next hook which is related to a very powerful React API,
              namely, the
              <a href="https://reactjs.org/docs/context.html">Context API</a>.
              We’ll soon be exploring the examples, however first comes a
              practical refresher how to use the Context API. It all starts with
              the context creation using <code>React.createContext</code>. It’s
              straightforward, the <code>createContext</code> function accepts
              an initial value. Based on the shape of the initial value, React
              is going to determine the type of the context, or the other way
              around - if you provide a type argument React is going to enforce
              the type of the initial value and all future values whom you’re
              going to set the context with.
            </p>
            <h4 id="component.contexttype">Component.contextType</h4>
            <iframe src=&#34;https://stackblitz.com/edit/react-contextype&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <h4 id="context.consumer">Context.Consumer</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-context-consumer-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <h4 id="usecontext">useContext</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usecontext-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <h3 id="ref-pattern">Ref pattern</h3>
            <p>
              The ref pattern commonly is utilized to access DOM node
              references. However, a ref object is generic and can hold a
              reference to basically anything. The reference is mutable and we
              can reassign values to it over time.
            </p>
            <blockquote>
              <p>
                Something which changes over time. But, wait, isn’t the
                practically the definition of <strong>state</strong>?! Does this
                mean that refs and state are the same thing?
              </p>
            </blockquote>
            <p>
              Yes, they are similar concepts, however there is a key difference.
              That difference lies in the fact that mutating a ref does not
              cause a rerender, unlike setting the state does.
            </p>
            <p>
              Practically, there’s an significant difference when it comes to
              interaction between refs and the <code>useEffect</code> hook,
              compared to state and <code>useEffect</code>, but let’s not get
              too fast ahead of ourselves.
            </p>
            <p>
              Now with that behind us. Since class fields are mutable by default
              , the simplest way to implement the ref pattern with class
              components is to just declare a class property. Bear in mind that
              the class field syntax in not yet part of the JavaScript spec,
              however it is one step away from. To quote MDN:
            </p>
            <blockquote>
              <p>
                Public and private field declarations are an
                <a href="https://github.com/tc39/proposal-class-fields"
                  >experimental feature (stage 3)</a
                >
                &gt; proposed at
                <a href="https://tc39.github.io/beta/">TC39</a>, the JavaScript
                standards committee. Support in browsers is limited, but ?&gt;
                the feature can be used through a build step with systems like
                <a href="https://babeljs.io/">Babel</a>.
              </p>
            </blockquote>
            <p>
              The good news for React developers who are using
              <code>create-react-app</code> is that we are able to use more than
              just ES2015 language features. One of these additional language
              features happens to be class fields, however
              <a
                href="https://create-react-app.dev/docs/supported-browsers-features/#supported-language-features"
                >here</a
              >
              is a complete list.
            </p>
            <h4 id="mutable-class-properties">Mutable class properties</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usereducer-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              <em>Note</em> if the <code>handleChange</code> property from the
              above example were a method instead, in the form of:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">handleChange() {
  /* handle change */
}
</code></pre>
            <p>
              Then the would not work correctly because the callback is invoked
              in the global context instead of the context of the class
              component. What this means piratically is that
              <code>this</code> would refer to the global object which in case
              of the browser is the <code>window</code> instance, whose value
              can be anything. Alternatively, we could have bound the method in
              the constructor:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">this.handleChange.bind(this)
</code></pre>
            <p>
              Which was a common practice before the introduction arrow
              functions and the class field syntax.
            </p>
            <p>
              “What’s the difference with arrow functions?” You may ask.
              Basically arrow functions do not have a dynamic context. Instead
              they “capture” the outer context in which they are declared in.
              Regardless of the context our <code>handleChange</code> function
              is invoked reference to <code>this</code> inside it’s body is
              going to refer to the component class context.
            </p>
            <p>
              With that in mind, that above example is still not going to
              function as intended. It demonstrates the difference between state
              and refs. The <code>console.log</code> gives us a little more
              insight what’s happening. Namely, the event target’s value is
              assigned to the name field. In the beginning the name property is
              equal to “Jane”. Furthermore, if you enter the letter “a” with
              your cursor positioned at the end of the input, the
              <code>handleChange</code> method is invoked with an event whose
              target’s value is “Janea”. Next, if you enter the letter “e”, the
              <code>handleChange</code> method is again going to be invoked. The
              question is, what is the name field’s value going to be after the
              assignment? Pause for a second to think about it. I’ll list out a
              few options:
            </p>
            <ol>
              <li>Jane</li>
              <li>Janeae</li>
              <li>Janea</li>
              <li>Janee</li>
            </ol>

            So what's the correct option? It may still be a little confusing and
            that is normal, but if you analyze the event step by step , like we
            did before, everything becomes clear. The event target's value is
            going to be "Janee" because the components render method hasn't been
            invoked since (granted that the parent component hasn't been
            rerendered either). Having established this the rest is the same as
            before. Namely the value of the target (input) at the time of the
            keyboard event taking place is "Jane" and the character "e" which
            was entered is appended to the end. Finally, the name value "Janee"
            is assigned to the name field.

            <br />
            <p>
              Now with that out of the way. We can use this property of refs to
              our advantage. In certain situations you may not want to have the
              component rerender, but you may still want to be able to react to
              the user’s input. In the following scenario we’ll keep track of
              the number of time the user clicked on the plus button until the
              count reaches 5, at which point the Count component is going to
              unmount and rely the information about the number of clicks to
              it’s parent
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/ref-pattern-mutable-class-properties&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              There’s one important detail to note here. Namely, in the
              <code>Count</code> component’s render method it is imperative not
              to destructure the count field. This is because, in JavaScript,
              numbers are among value types which. In contrast to reference
              types like objects, when a value type is assigned to a constant or
              variable, a new value is created and the constant or variable
              which is being assigned to becomes a reference to the newly
              created object. In this case, since we want to mutate the class
              property, hence we may to access the reference to the variable
              through the <code>this</code> object.
            </p>
            <h4 id="accessing-dom-node-references">
              Accessing DOM node references
            </h4>
            <p>
              Bear in mind the example we are about to see can be improved upon
              and we will do so in a subsequent section.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/accessing-dom-node-references&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              In the example above we used the
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect"
                >getBindingClientRect</a
              >
              method on the
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div"
                >HTMLDivElement</a
              >
              instance to get the element’s width and height, in pixel units, at
              moment in time. Next, we set the component state causing the
              render method to be invoked once again, this time with the updated
              width and height values.
            </p>
            <h4 id="accessing-a-class-component-instance">
              Accessing a class component instance
            </h4>
            <p>
              The ref prop is a special prop in the sense that you cannot access
              it inside a component by typing <code>this.props.ref</code> in
              case of class components. Although, if you pass a ref to a class
              component’s instance you’ll have access the instance object.
              Meaning that you will be able to imperatively invoke methods on
              the component and access public properties.
            </p>
            <blockquote>
              <p>When would this be useful?</p>
            </blockquote>
            <p>
              A prime example is setting the focus on an input element. Consider
              the text editor library
              <a href="https://npmjs.org/package/draft-js">draft-js</a>. From my
              experience, the library has a hockey stick like learning curve.
              Meaning that it is difficult to learn at first, but once you grasp
              the basic concepts and mechanisms it becomes rather easy to do
              more complicated stuff with it. To quote the official
              <a
                href="https://draftjs.org/docs/advanced-topics-managing-focus/#__docusaurus"
                >draft-js docs</a
              >
            </p>
            <blockquote>
              <p>
                Managing text input focus can be a tricky task within React
                components. The browser focus/blur API is imperative, so setting
                or removing focus via declarative means purely through
                <code>render()</code> tends to feel awkward and incorrect, and
                it requires challenging attempts at controlling focus state.<br />
                With that in mind, at Facebook we often choose to expose
                <code>focus()</code> methods on components that wrap text
                inputs. This breaks the declarative paradigm, but it also
                simplifies the work needed for engineers to successfully manage
                focus behavior within their apps.
              </p>
            </blockquote>
            <iframe
            src=&#34;https://stackblitz.com/edit/accessing-class-component-instance&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              The editor component is basically a <code>textarea</code>, except
              that it isn’t a text area but instead relies on
              <a
                href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Editable_content"
                >contentEditable</a
              >
              which brings with itself a whole class of issues like cross
              browser inconsistencies. If you’re interested in this topic you
              can check out <a href="https://youtu.be/feUYwoLhE_4">video</a> by
              Isaac from the draft team. Luckily for us, the draft team has
              overcome these obstacles and presented draft-js users with a nice
              API.
            </p>
            <h4 id="createref">createRef</h4>
            <p>
              In the section <strong>Accessing DOM node references</strong> I
              told you that the example can be improved upon and the time has
              come to see how.
            </p>
            <iframe src=&#34;https://stackblitz.com/edit/react-create-ref&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <blockquote>
              <p>That’s it? Doesn’t seem like much of an improvement</p>
            </blockquote>
            <p>
              Indeed, it’s not a quantum leap. However, we didn’t have to
              explicitly type the <code>editorRef</code> property. Instead we
              passed the type of object whose reference we’d like to store.
            </p>
            <blockquote>
              <p>
                Why did you pass <code>EditorState | null</code>, instead of
                just <code>EditorState</code>
              </p>
            </blockquote>
            <p>
              Thanks for the question, this ties in with the constructor which
              too is newly added. Inside the body of the constructor method the
              value of <code>this.editorRef</code> is logged. At which point the
              ref is equal to <code>{ current: null }</code>. We already
              mentioned that at the time of <code>componentDidMount</code> being
              invoked, refs will already have been updated. This means that the
              refs are updated somewhere in between the constructor phase and
              the before the mount phase.
            </p>
            <p>
              The life cycle doesn’t finished there though. In the above example
              there’s also an additional
              <code>componentWillUnmount</code> method along with the App
              component which renders a button, which when clicked mounts or
              unmounts the <code>MyEditor</code> component. Pay attention to an
              extra difference between manually creating a ref object compared
              to using <code>React.createRef</code>. Namely, React is going to
              take care of setting the ref object, returned by invoking
              <code>React.createRef</code>, to back to
              <code>{ current: null }</code> again.
            </p>
            <blockquote>
              <p>Why is this a good thing?</p>
            </blockquote>
            <p>
              Simply, the DOM node whose reference is stored in the class
              property does not exist in the DOM anymore after the component has
              been unmounted. React plays the role of your friend telling you
              that the coupon for the Indian restaurant which you were planning
              to spend is no longer valid because the restaurant already closed
              down. So going to the restaurant would be a waste.
            </p>
            <p>
              In conclusion, when using the <code>React.createRef</code> API to
              access a DOM node’s reference. Initially the ref object’s current
              property is going to be equal to <code>null</code>. After the
              constructor phase and before <code>componentDidMount</code> is
              invoked, the ref object’s current property is going to be a
              reference to the given DOM node. Finally, before
              <code>componentWillUnMount</code> is invoked the ref object’s
              current property is once again going to equal to
              <code>null</code>.
            </p>
            <h4 id="refs-and-functional-components">
              Refs and functional components
            </h4>
            <p>
              Functional components do not support refs out of the box, since
              they are stateless and not produce object instances like classes.
              We can however forward a ref from a functional component.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/refs-and-functional-components&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              The first type parameter of forwardRef is the type of HTML element
              the ref is going to be forwarded to. Whereas the second one
              represents the props of the component. Furthermore, the callback
              passed to the forwardRef function now received an additional
              second argument which is the ref to be forwarded. To which element
              the ref is going to be forwarded exactly is up to the functional
              component to decide.
            </p>
            <p>
              Furthermore, if you’ve ever searched the web for a React component
              library chances are that you’ve come across
              <a href="https://material-ui.com">material UI</a> at some point.
              According to the following npm trends
              <a
                href="https://www.npmtrends.com/@material-ui/core-vs-antd-vs-react-bootstrap-vs-reactstrap-vs-semantic-ui-react"
                >chart</a
              >
              material ui is the most popular React component library.
              Popularity aside, material ui is a set of react components which
              implement the
              <a href="https://material.io/design">material design spec</a>. If
              you’ve used any of Google’s products chances are that you’ve got a
              taste of the material design look and feel. Apart from that
              material ui has a wide assortment of component you can choose from
              which is ever evolving through
              <a href="https://npmjs.org/package/@material-ui/lab"
                >@material-ui</a
              >. All of the components are well documented with lots of examples
              and there’s even a theming system and a <code>Box</code> component
              primitive. There’s also a few quirks here and there as
              demonstrated above.
            </p>
            <p>
              As a side note, I haven’t been payed to promote them, I laid out
              the major benefits of the library so that some of you may resonate
              with them.
            </p>
            <h4 id="useref">useRef</h4>
            <p>
              There was a lot to take in when in comes to refs however if you’ve
              come this far you may indulge in the ergonomics of the
              <code>useRef</code> hook.
            </p>
            <iframe src=&#34;https://stackblitz.com/edit/react-use-ref&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              Once again, the code is quite a bit more concise. However, the
              <code>editorRef</code> declaration looks eerily similar to the
              above example where we used <code>createRef</code>.
            </p>
            <blockquote>
              <p>
                Then, what’s the difference between between
                <code>useRef</code> and <code>createRef</code>? What would
                happen if we replaced the <code>useRef</code> call above with an
                <code>createRef</code> invocation?
              </p>
            </blockquote>
            <p>
              You wouldn’t immediately notice a difference, however, it’s not
              recommended to use <code>createRef</code> inside the body of a
              functional component because of performance reasons. That is
              because <code>createRef</code> returns a new reference each time
              it is invoked, in this case being every time the FC is rendered.
              In the context of a single component life cycle,
              <code>useRef</code>, is always going to return the same reference.
            </p>
            <p>
              What a build up and culmination, but I feel like something is
              missing…
            </p>
            <p>
              Up until now, we talked about how refs can represent DOM node
              instances or class component instances. However we also talked
              about how refs can be basically anything. Furthermore, being able
              to access public properties on class component instance and
              imperatively invoke the methods seems like quite an advantage.
              This is, after all, a very common pattern in frameworks like
              Angular. This section is dedicated to the ones who asked
              themselves how this mechanism could be applied to functional
              components.
            </p>
            <p>
              It might not seems perfectly clear how to go forward, but for
              starters, we know how to forward a ref to a functional component.
              In a sense, a functional component is equivalent to class
              component instance’s render method. As such, it may be difficult
              to imagine how a FC can harbor properties and method. The answer
              is simple. Constants and variables declared inside the function
              body may represent properties and functions may represent method.
            </p>
            <blockquote>
              <p>
                But, what about a shared context, through <code>this</code>?
              </p>
            </blockquote>
            <p>
              Guess what, the body of a functional component represents already
              context which is shared across variables and functions.
            </p>
            <p>
              Taking this idea a step further, in contrary to class components
              everything inside a FC’s body is private by default. Meaning that
              the outside world has no knowledge of any variables or functions
              declared inside it. However, we do want to expose certain
              variables and functions. and we can easily do so by mutating the
              ref’s <code>current</code> property.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-use-imperative-handle&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              It works exactly like you’d expect it to. However, there are a few
              things to note here. Starting with the
              <code>if (ref)</code> inside the <code>Hello</code> component. It
              seems excessive according to the type signature of the
              <code>ref</code> which is
              <code
                >((instance: IHello) =&gt; void) |
                React.MutableRefObject&lt;IHello&gt;</code
              >. There is no mentioned of <code>null</code> or
              <code>undefined</code>, however if you do not pass a ref to the
              component upon instantiation, like <code>&lt;Hello /&gt;</code>,
              then the <code>ref</code> will simply be <code>null</code> when
              you try to access it in the scope of the
              <code>Hello</code> component. Although, it’s not likely that the
              consumer of the <code>Hello</code> component is going to omit the
              ref prop it is still a very real possibility considering that the
              TypeScript compiler issues no warnings or errors if you
              instantiate the component without providing a ref. This detail may
              lead to a runtime error and if we don’t test how the
              <code>Hello</code> component renders, the error may split by
              development unnoticed.
            </p>
            <blockquote>
              <p>
                Okay, but what’s up with the
                <code>((instance: IHello) =&gt; void)</code> part?
              </p>
            </blockquote>
            <p>
              To quote the
              <a
                href="https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"
                >React docs</a
              >:
            </p>
            <blockquote>
              <p>
                React also supports another way to set refs called “callback
                refs”, which gives more fine-grain control over when refs are
                set and unset.<br />
                Instead of passing a <code>ref</code> attribute created by
                <code>createRef()</code>, you pass a function. The function
                receives the React component instance or HTML DOM element as its
                argument, which can be stored and accessed elsewhere.
              </p>
            </blockquote>
            <p>
              You may not need to use the option, but it’s nice to know that it
              exists. Although don’t shy away from pointing out TypeScript’s
              shortcomings, and the shortcomings of type declarations provided
              by library authors and developers, the main point is that
              TypeScript still enables us to have an insight as to how a symbol
              can be used based on it’s type signature. I am a very lazy person
              by nature and I don’t always like looking up documentation.
              Ideally, I like to find out how to a third part function by simply
              hovering over the symbol in
              <a href="https://code.visualstudio.com/">VSCode</a>. As a cherry
              on top, VSCode also has first class support for
              <a href="https://jsdoc.app/about-getting-started.html">JSDoc</a>,
              meaning that information which is difficult if not impossible to
              convey through types at the moment can be expressed in plain
              English with a comment. This way you can annotate both function,
              classes, object, interfaces and so on.
            </p>
            <blockquote>
              <p>
                But, wait, even if I use JavaScript in VSCode I am able to look
                at the type signature of the ref.
              </p>
            </blockquote>
            <p>
              That’s true, but under the hood VSCode is running a TypeScript
              <a
                href="https://github.com/microsoft/TypeScript/wiki/Standalone-Server-(tsserver)"
                >server</a
              >
              to be able to do any type checking.
            </p>
            <p>
              To get back to the main branch of discussion. If the
              <code>ref</code> exists and <code>ref.current</code> is not of
              type “function”, then we can feel free to assign an object which
              has a clear property to <code>ref.current</code>.
            </p>
            <p>
              On the other hand, each time the component renders the variables
              and functions which are declared inside it are redeclared. The
              assignment to <code>ref.current</code> also needlessly happens
              each time. And those if checks are not very nice to look at. Not
              to beat around the bush anymore, there is a dedicated hook,
              created by the React team, for exactly this purpose.
            </p>
            <h4 id="useimperativehandle">useImperativeHandle</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-useimperativehandle-hook&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              It covers all of the edge cases which we mentioned before and it
              provides a nice outward facing API.
            </p>
            <p>
              Importantly, being an imperative API,
              <code>useImperativeHandle</code> is not meant to be a tool which
              you rely on constantly because it’s not in line with React’s
              philosophy of functional, declarative programming. It’s not bad
              per se, however there is probably a more elegant and idiomatic way
              to perform a given task.
            </p>
            <h3 id="lifecycle-methods">Lifecycle methods</h3>
            <p>
              Hooks are used inside functional components and we already
              established, from the pre-hooks era, that there is no such thing
              as a functional component instance because it has no life cycle.
              There is no difference between the first render of a functional
              component as it is first mounted in the DOM (before it was not
              present in the virtual DOM hierarchy nor in the real DOM) and the
              last render, where the component is removed from the DOM. However,
              if we want to put class components aside and only use functional
              components, to implement the state pattern and life cycle pattern
              there has to be a way for developers to track the life cycle of
              FC’s. At least the mounting, updating and unmounting phases. Hooks
              bridge that gap and one such essential hook is the
              <code>useEffect</code> hook.
            </p>
            <p>
              A very important thing to note is that every hook is effectful and
              functional components which consume a hook are impure. A function
              which doesn’t perform a side effect, even if it has “use” in its
              name, is not a hook but a pure function.
            </p>
            <p>
              The convention to prefix each hook with “use” was proposed by the
              React team, similarly how each higher order component was prefixed
              with “with”. Khm <code>connect</code>, shame on you
              <code>react-redux</code>. The goal of the naming convention is to
              communicate to developers that a function has some special
              properties. In the case of hooks, it is the impure nature as well
              as the ability to trigger rerender among others. This is
              especially important in the case of hooks compared to HOC’s, since
              higher order components were distinguishable by their type
              signature which is:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">type HOC = &lt;InputProps, OutputProps&gt;(component: React.ComponentType&lt;InputProps&gt;) =&gt; React.ComponentType&lt;Output&gt;
</code></pre>
            <p>
              Whereas, the type signature of hooks is more generic and less
              recognizable:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">type Hook = (...args: []) =&gt; any
</code></pre>
            <p>
              In fact, the above is a type signature of any function for that
              matter. Based on the type signature alone, any function may or may
              not be a hook. However if you prefix your custom hooks with “use”
              is an important gesture towards your future self and other
              developers who are going to be working with your code.
              Furthermore, the highlight of this series is the
              <strong>Creating your own hooks</strong> section, where we’ll
              learn how to build world class custom hooks.
            </p>
            <p>
              Before we start going through all of the examples, let me ask you
              this.
            </p>

            What the functional programmer answer to any object oriented
            pattern? Of course, it's <i>a function</i> every time.

            <br />
            <blockquote>
              <p>How does this tie in into life cycle methods?</p>
            </blockquote>
            <p>
              Simply, the answer to any life cycle method in the context of
              hooks is
              <a href="https://reactjs.org/docs/hooks-reference.html#useeffect"
                >useEffect</a
              >.
            </p>
            <p>
              To understand the <code>useEffect</code> hook in it’s entirety
              took me quite a bit of time. Apart from reading the through the
              documentation I experimented a lot with the hook and through many
              iterations I was able to say that I have a thorough grasp of the
              hook.
            </p>
            <p>
              In this section, we are going to go through a lot of examples step
              by step and incrementally learn everything you need to know to
              become a <code>useEffect</code> ninja.
            </p>
            <p>
              One more heads up before we start. Thinking in terms of utilizing
              the <code>useEffect</code> hook can be difficult at first since it
              requires a shift in perspective. However, do not beat yourself up
              about it. After enough practice you will build up a solid
              intuition.
            </p>
            <h4 id="componentdidmount">componentDidMount</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-componentdidmount-example&#34;
            width&#34;100%&#34; height=&#34;500px&#34; />
            <h4 id="useeffect-on-mount">useEffect on mount</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-useeffect-on-mount&#34;
            width=&#34;100%&#34; height-&#34;500px&#34; />
            <p>
              This is easy! The first argument passed to <code>useEffect</code>,
              as with the <code>componentDidMount</code> callback, represents a
              function which will be invoked by React. Now, when it is going to
              be invoked is more obvious in the case of
              <code>componentDidMount</code> based on its name. On the other
              hand, when it comes to <code>useEffect</code>, when the callback
              is going to be invoked depends entirely on the second argument,
              which represents the dependencies array. The gist of it is simple.
              Each time a dependency changes, React will invoke the callback.
            </p>
            <p>
              Although React is not going to complain about it, it’s important
              that you pass a second argument to the
              <code>useEffect</code> callback. Else the callback you passed as
              the first argument would be invoked each time the component
              renders.
            </p>
            <p>
              However, there is a difference between invoking a function inside
              of the body of a FC, compared to passing a callback function to
              <code>useEffect</code>, even if you do not pass a second argument
              to <code>useEffect</code>. That being the first invocation.
              Namely, the naked function call is going to be invoked before the
              <code>usEffect</code> callback, before the component has been
              mounted. You may draw a parallel between the constructor
              invocation which happens before <code>componentDidMount</code> is
              called. This means that is it safer to perform any DOM related
              side effects as part of t <code>useEffect</code> callback.
            </p>
            <p>
              This topic ties into server side rendering. Entailing that your
              component is not going to be mounted when React is rendering your
              App to a string, hence <code>useEffect</code> callbacks will not
              be invoked during the process of server side rendering. This is a
              limiting circumstance at the moment because you will not be able
              to hydrate your app with data during server side rendering, since
              you cannot perform a side effect like fetching a resource inside
              the <code>useEffect</code> callback.
            </p>
            <p>
              Fortunately, with the introduction of the new
              <a href="https://reactjs.org/docs/concurrent-mode-adoption.html"
                >React Concurrent Mode</a
              >, looking at the
              <a
                href="https://reactjs.org/docs/concurrent-mode-adoption.html#feature-comparison"
                >feature comparison</a
              >, there will be first class support for server side rendering and
              hydration.
            </p>
            <p>
              If you’ve never heard of the new <code>Concurrent Mode</code>,
              don’t feel bad about it, since it’s pretty much brand new at the
              moment and it hasn’t yet fully caught on. However,
              <code>Concurrent Mode</code> is the future for React application
              since it offers so many things which were previously impossible to
              accomplish. Basically, the reason why it is called concurrent is
              because React is now able to render your app in a separate thread,
              without blocking the main thread. This is significant because
              React is not able to fully render your application’s new state
              before committing the update to the DOM. You can read up e details
              <a href="https://reactjs.org/docs/concurrent-mode-intro.html"
                >here</a
              >
              and even fiddle around with the Suspense API among others.
              Furthermore, If you guys are interested, I’d be happy to create a
              series, similar to this one oriented towards React’s
              <code>Concurrent Mode</code> .
            </p>
            <p>
              For now let’s focus on the topic at hand. Above I mentioned that
              the <code>useEffect</code> callback is going to be invoked when
              one of your dependencies changes. What does that mean exactly?
              Let’s dissect the following example to get more insight.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-useeffect-change-detection&#34;
            width=&#34;100%&#34; height=&#34;100%&#34; />
            <p>
              Clicking on <code>Turn on</code> is not going to rerender the App
              component, since the <code>isOn</code> state is being set to the
              same state as the current. Naturally, the Switch component’s
              <code>useEffect</code> callback is not going to fire either.
              Secondly, if you click on the <code>Toggle on</code> button, the
              App is going to rerender followed by the Switch component. This
              time, since the value of the <code>isOn</code> is different
              compared to the previous render, React is going to invoke the
              <code>useEffect</code> callback. Thirdly, if you then click on the
              <code>Turn on</code> button, the cycle rerenders is going to
              repeat. Now comes the interesting part though. The value of the
              <code>isOn</code> state is <code>true</code> at that moment and if
              you click on <code>Turn on</code> again, the App is going to
              rerender, as seen by the <code>console.log</code>. On the other
              hand, the <code>useEffect</code> callback<br />
              is not invoked since the value of the <code>isOn</code> prop
              passed to the <code>Switch</code> component has not changed
              compared to the its value during the previous render.
            </p>
            <h4 id="componentwillunmount">componentWillUnmount</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-component-will-unmount&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              This was pretty straight forward, with nothing out of the
              ordinary. Next up, we’ll see how the pattern translates to
              functional components and hooks.
            </p>
            <h4 id="useeffect-will-unmount">useEffect will unmount</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-useeffect-will-unmount&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              Couldn’t be easier, could it? I feel like a broken record, but
              once again the code is more simpler and more concise.
            </p>
            <p>
              Now, as to what the important details in the above example are. As
              you probably noticed the <code>useEffect</code> callback is
              returning a function. This function being returned is usually
              aptly called the cleanup function and this is where you perform
              your your cleanup duties, like unsubscribing from a data source.
              React will invoke that function each time the
              <code>useEffect</code> callback is ran, expect for the first time
              (this gave me a lot of confusion on the past). There’s one more
              exception to the rule, specifically, the cleanup function is also
              invoked when the component is about to be unmounted.
            </p>
            <h4 id="componentdidupdate">componentDidUpdate</h4>
            <p>
              Now that you know what React does with the dependency array in
              relation to the callback function and the cleanup function this
              section should be a breeze.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-componentdidutpdate-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              In case that we want to perform a side effect like logging to new
              value of a prop to the console, each time the given prop changes,
              we can easily do so by utilizing the
              <code>componentDidUpdate</code> hook. React will invoke the
              callback each time any of the props change thus executing our
              code. This entails that the responsibility for comparing props or
              performing any other logic for that matter is completely up to us.
              You’ll soon see why this was brought up.
            </p>
            <h4 id="useeffect-did-update">useEffect did update</h4>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-useeffect-did-update&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              The dependency management mechanism is inverted in this case.
              Meaning that the callback is not going to be invoked unless a
              dependency is stated explicitly. Additionally, we do not have to
              perform a comparison of the props anymore, however the downside is
              that we do not have access to the previous props either. Although
              there exists a simple workaround and we going to be implementing
              in a section to come.
            </p>
            <p>
              Let’s first talk a bit more the dependencies. At this point, we
              know what the dependencies represent and how React manages the
              dependency array which we provide. Now, we are going to touch upon
              the why and the best practices around managing dependencies.
            </p>
            <h4 id="the-why-of-dependencies">The why of dependencies</h4>
            <p>
              So, why does the dependency array even exist. If you think about
              it, the compiler could conclude what the dependencies of
              <code>useEffect</code> callback are based on the variables which
              we refer to in the callback. It is possible and the React
              documentation even states:
            </p>
            <blockquote>
              <p>
                The array of dependencies is not passed as arguments to the
                effect function. Conceptually, though, that’s what they
                represent: every value referenced inside the effect function
                should also appear in the dependencies array. In the future, a
                sufficiently advanced compiler could create this array
                automatically.
              </p>
            </blockquote>
            <p>
              This insert hints at the total removal of the dependency array.
              However, there would still be a need for a way to convey the
              information that a certain effect should be run only once.
              Otherwise, it would come down to an if statement inside the
              callback whose responsibility would be to determine whether based
              on the current state of the world. Something along the lines of:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">React.useEffect(() =&gt; {
  if (status === 'initial') {
    setStatus('loading')
    fetchResource()
  }
})
</code></pre>
            <h4 id="uselayouteffect">useLayoutEffect</h4>
            <p>
              The following hook, called <code>useLayoutEffect</code>, is
              similar to <code>useEffect</code>. In some situations the 2 of
              them will be interchangeable. In which case the React team
              recommends using <code>useEffect</code>. What follows is a great
              tip from the official docs:
            </p>
            <blockquote>
              <p>
                If you’re migrating code from a class component, note
                <code>useLayoutEffect</code> fires in the same phase as
                <code>componentDidMount</code> and
                <code>componentDidUpdate</code>. However,
                <strong
                  >we recommend starting with
                  <code>useEffect</code> first</strong
                >
                and only trying <code>useLayoutEffect</code> if that causes a
                problem.<br />
                If you use server rendering, keep in mind that <em>neither</em>
                <code>useLayoutEffect</code> nor <code>useEffect</code> can run
                until the JavaScript is downloaded. This is why React warns when
                a server-rendered component contains
                <code>useLayoutEffect</code>. To fix this, either move that
                logic to <code>useEffect</code> (if it isn’t necessary for the
                first render), or delay showing that component until after the
                client renders (if the HTML looks broken until
                <code>useLayoutEffect</code> runs).<br />
                To exclude a component that needs layout effects from the
                server-rendered HTML, render it conditionally with
                <code>showChild &amp;&amp; &lt;Child /&gt;</code> and defer
                showing it with
                <code>useEffect(() =&gt; { setShowChild(true); }, [])</code>.
                This way, the UI doesn’t appear broken before hydration.
              </p>
            </blockquote>
            <p>
              It’s important to note that <code>useLayout</code> fire
              synchronously after all DOM mutations and gives you a chance to
              execute a callback at the cost of blocking rendering by preventing
              the browser from painting. So do not perform any blocking or
              heavily computational operations inside the hook if you want your
              component to be visible on the screen as soon as possible. Don’t
              even use the <code>useLayoutEffect</code> hook if you don’t have
              to.
            </p>
            <blockquote>
              <p>So what’s the hook even good for, anyway?</p>
            </blockquote>
            <p>
              You will know when the time comes to use it. For example, if your
              component needs to be aware of it’s size and position before it is
              rendered for the first time. If part B of the layout depends on
              the dimensions of part A of the layout and you want to avoid a
              flash of unstyled content.
            </p>
            <p>Let’s see the example:</p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-uselayouteffect&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              This might seem like a niche use case. Regardless, the React team
              has got us covered. This is one of those moments which instills
              confidence in React as a tool all encompassing tool for building
              web applications.
            </p>
            <p>
              Lastly, you may already be familiar with the usage of
              <code>React.Fragment</code>, it’s a way to be able to return
              multiple elements at once. They are still wrapped in a
              <code>React.Fragment</code> however the fragment is stripped at
              build time and is not present in the DOM. You may also have seen
              the newer syntax for fragments which is more concise,
              <code>&lt;&gt;/\* content \*/&lt;/&gt;</code>. Yes, they look like
              empty HTML tags. However the Stackblitz React TypeScript template
              does not support it at the moment and fails to parse the symbols.
              Fragments are a nice way to avoid having
              <a
                href="https://www.chillybin.com.sg/would-you-like-another-bowl-of-div-soup/"
                >div soups</a
              >. Nevertheless, like any other good thing, don’t overuse them.
              Believe me, I got burned once when I ended up with a broken
              layout. Long story short, by wrapping two sections in a fragment
              instead of a div. The 2 sections distributed evenly across the
              parent flex container, instead of splitting 1 fraction among
              themselves. Luckily for me, it was easily noticeable.
            </p>
            <h3 id="properties-and-methods">Properties and methods</h3>
            <p>
              We talked about how functional component, with the additional of
              hooks, stand toe to toe with class component in almost any field.
              However, up until now you may have noticed that something is not
              quite there. In other words, if we declare a constant or function
              inside a functional component it gets redeclared and recomputed
              each time the FC renders. The re-declaration entices referential
              inequality and re-computation spends additional resources. The
              downsides of these two factors is usually not detrimental, but
              there is a solution for this conundrum as well. The solution comes
              in the form of the <code>useMemo</code> hook and it’s specialized
              version called <code>useCallback</code>. Let’s first explore the
              elder of the two siblings.
            </p>
            <h4 id="usememo">useMemo</h4>
            <p>
              As its name suggests, the point of the <code>useMemo</code> hook
              is to enable
              <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a
              >, preventing needless recalculation.
            </p>
            <blockquote>
              <p>What does this mean exactly ?</p>
            </blockquote>
            <p>
              As you might know, every pure function have certain neat
              properties. Starting with the fact that they always return the
              same output for a given input. They are just pure data
              transformations. Based on this, you could create a table of
              mapping certain inputs to certain outputs, for any input (given
              that the function is also total - for every input there’s a well
              defined output) and any pure function ever.
              <code>useMemo</code> takes advantage of this property and memoizes
              the callback. Under the hood, it creates a table of know input and
              output mapping. If at any point it receives a known input, the
              input is mapped to an output and returned without the need to
              invoke the callback.
            </p>
            <p>
              So pay attention to the mentioned of pure part, even though the
              signature of <code>useMemo</code> looks similar to
              <code>useEffect</code> - side effect don’t belong in
              <code>useMemo</code><br />
              callbacks. Effectful functions do not exhibit the same properties.
            </p>
            <p>
              Without further ado, let’s see what the <code>useMemo</code> hook
              can offer us.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usememo-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              The first usage of <code>useMemo</code> is trivial. What’s more,
              the first argument passed to <code>useMemo</code> is a callback
              which when invoked return the ordinal which is the result of
              casting the text representation of the input’s value to a number
              using th <code>Number</code> constructor. It doesn’t save us much
              computational resources however it prevents the ordinal constant
              from being redeclared each time the App renders.
            </p>
            <blockquote>
              <p>Is this really worth it?</p>
            </blockquote>
            <p>
              That’s a good question. Since the usage of
              <code>useMemo</code> impacts readability, I’d rather not write use
              it everywhere unless there’s a fathomable benefit to using it.
              There are plenty of ways to measure the impact of the
              <code>useMemo</code> hook and soon we are going to see for
              ourselves. However, let’s first get acquitted with the little
              brother of <code>useMemo</code>.
            </p>
            <h4 id="usecallback">useCallback</h4>
            <p>
              As its name says, <code>useCallback</code> is often used to wrap
              callbacks. And the docs say a little more about it:
            </p>
            <blockquote>
              <p>
                Pass an inline callback and an array of dependencies.
                <code>useCallback</code> will return a memoized version of the
                callback that only changes if one of the dependencies has
                changed. This is useful when passing callbacks to optimized
                child components that rely on reference equality to prevent
                unnecessary renders (e.g. <code>shouldComponentUpdate</code>).
              </p>
            </blockquote>
            <p>
              At its heart <code>useCallback(fn, deps)</code> is equivalent to
              <code>useMemo(() =&gt; fn, deps)</code>.
            </p>
            <p>
              Here’s an example which you may come across in the wild,
              debouncing an effectful function which depends on an input value.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usecallback-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              We aren’t passing an inline lambda function to
              <code>useCallback</code> because the return type of higher order
              <code>debounce</code> function is a function. Higher order
              function means exactly, a function which also returns a function.
              This is similar to another familiar concept which we will be
              discussing called higher order components. Even if you weren’t
              sure before, applying the same logic you already know what higher
              order components are. Back to the debounce example, be careful not
              to debounce the value setter else the input will appear broken.
            </p>
            <h4 id="usememo-vs-react.memo">useMemo vs React.memo</h4>
            <p>
              It is worth mentioning that <code>useMemo</code> and
              <code>React.memo</code>, despite having a similar name, have many
              things in common apart from that. Let’s look at the signatures of
              each function, starting with <code>useMemo</code>:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">type useMemo = &lt;Value&gt;(callback: () =&gt; Value, dependencies: any[]) =&gt; void
</code></pre>
            <p>Compared to <code>React.memo</code>:</p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'
type memo = &lt;Props extends {}&gt;(component: (props: Props) =&gt; React.ReactNode, arePropsEqual: (prevProps, nextProps) =&gt; boolean) =&gt; void
</code></pre>
            <p>
              Firstly, <code>memo</code> doesn’t accept a dependencies array,
              but instead accept a function as the second argument. When the
              function returns true, it signals to React that the props are
              equal to the previous props by the criteria you establish, and a
              rerender is unnecessary. Although, the comparison function
              represent an optional argument, and if it’s not provided a shallow
              comparison is performed by React.
            </p>
            <p>
              And also noticeably, the callback param of
              <code>useCallback</code> doesn’t any parameters.Let’s now spice
              things up by use
              <a href="https://npmjs.org/package/rxjs">rxjs</a> to subscribe to
              a service which return a new value every second. With
              subscriptions you’re probably used to unsubscribing in the
              unmounting phase, from which point on the component instance no
              longer exists and keeping the subscription running would be a
              memory leak. This is even suggested by React’s error message
              during development, when there’s an attempt to update the state of
              a component which has been unmounted.
            </p>
            <h4 id="is-memoization-worth-it">Is memoization worth it</h4>
            <p>
              From my very first contact with the memoization hooks (<code
                >useMemo</code
              >
              and <code>useCallback</code>), I liked the idea of being able to
              further optimize my code’s performance. However as we discussed,
              the usage of the before mentioned hooks comes at the cost of
              readability. So in order to be able to make quality decisions on
              whether or not the trade-off is worth it in a given situation, it
              is essential to know the impact and have proof concrete backing up
              your decisions. Fortunately, React provides us with a Swiss army
              knife of tools one of which is the
              <a href="https://reactjs.org/docs/profiler.html">Profiler</a>
              component. The <code>Profiler</code> is very powerful and yet very
              simple to use.
            </p>
            <p>
              The majority of the complexity related to the
              <code>Profiler</code> comes down to the
              <code>onRender</code> callback. It accepts a number of arguments:
            </p>

            <table>
              <thead>
                <tr>
                  <th>prop</th>
                  <th>description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>id</td>
                  <td>
                    the “id” prop of the Profiler tree that has just committed
                  </td>
                </tr>
                <tr>
                  <td>phase</td>
                  <td>
                    either “mount” (if the tree just mounted) or “update” (if it
                    re-rendered)
                  </td>
                </tr>
                <tr>
                  <td>actualDuration</td>
                  <td>time spent rendering the committed update</td>
                </tr>
                <tr>
                  <td>baseDuration</td>
                  <td>
                    estimated time to render the entire subtree without
                    memoization
                  </td>
                </tr>
                <tr>
                  <td>startTime</td>
                  <td>when React began rendering this update</td>
                </tr>
                <tr>
                  <td>commitTime</td>
                  <td>when React committed this update</td>
                </tr>
                <tr>
                  <td>interactions</td>
                  <td>the Set of interactions belonging to this update</td>
                </tr>
              </tbody>
            </table>
            <p>
              We are going to be focusing on the properties which enable us to
              determine the effects of <code>useMemo</code>. Firstly, the
              <code>id</code> is required and its of type string. The string
              should match the name of the component you rare profiling. It is
              also required for the component being profiled appear as a child
              of the respective <code>Profiler</code>. Secondly, the
              <code>actualDuration</code>. It is going to be the limelight of
              the experiments. The reason for it is encompassed by the following
              insert from the docs:
            </p>
            <blockquote>
              <p>
                actualDuration: number - Time spent rendering the Profiler and
                its descendants for the current update. This indicates how well
                the subtree makes use of memoization (e.g. React.memo, useMemo,
                shouldComponentUpdate). Ideally this value should decrease
                significantly after the initial mount as many of the descendants
                will only need to re-render if their specific props change.
              </p>
            </blockquote>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-profiler-example&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              This is the setup and experiment which will be performed
              illustrates the point but is rather simple. Namely, the
              <code>getFibonacci</code> function is going to enable us to
              incrementally increase the computational strain on the
              non-memoized component which will sooner or later stand out
              compared to the memoized version. What’s more, the
              <code>actualDuration</code> of the render for the memoized
              component should stay roughly the same in the case that we are not
              updating any dependency of the <code>getFibonacci</code> function
              (the <code>ordinal</code> to be exact). The
              <code>getFibonacci</code> function’s time complexity increases
              drastically as we increase the ordinal, to the point that after
              having entered <code>9999</code> I received a stackoverflow
              error(this was performed on a second generation Ryzen 7 laptop).
              Since there is a significant jump in complexity with each
              additional digit the idea is to run benchmarks for a single,
              double and triple digits. Furthermore, to be able to compare the
              results we are going to render a non-memoized and a memoized
              version of the Fibonacci component. By non-memoized I mean a
              component which calculates the Fibonacci number at a given place
              based on the supplied ordinal prop. Each time the component
              renders the computation is going to be performed form the ground
              up. Whereas the memoized sibling of the component has the
              computation wrapped in a <code>useMemo</code> hook with a single
              dependency, the ordinal, which is passed as an argument to the
              <code>getFibonacci</code> function. On the other hand, we are not
              going to be running the tests for both component simultaneously
              since they rely on the same state. Although, every step along the
              way, including the most insightful growth rate statistic are going
              to be logged to the console. In this example I specified 50
              iterations and based on the profiler data from those 50 iterations
              an average is induced. Moreover, based on the averages the growth
              rates are calculated from lower to higher (left to right).
            </p>
            <p>
              After a couple of runs, in case of the memoized component the
              growth rates where deviations I observed where around 20%.
              Although the averages, in case of the memoized component, are
              expected to be roughly the same, there are divinations and that is
              normal considering that the <code>actualDuration</code> is a small
              number. Meaning that the absolute differences are miniscule. On
              the other hand after having ran the non-memoized version of the
              component a number of times some distinctions where obvious.
              Namely, the growth rate from the 9th to the 99th was circa 20% on
              average. Although as mentioned before this isn’t a significant
              amount, however the increase was rather consistent. Moreover, the
              growth rate from the 99th to the 999th shot up by a more
              significant margin. Around 300% on average, now that is a more
              noticeable result.
            </p>
            <p>
              The conclusion is that’s probably not necessary to memoize simple
              expressions and functions unless you are working on a piece of
              code in the critical path or you require referential integrity to
              be preserved when working with highly optimized components.
            </p>
            <h2 id="rules-of-hooks">Rules of hooks</h2>
            <p>
              I shall share with you a summary the dedicated section in the
              official docs, called
              <a href="https://reactjs.org/docs/hooks-rules.html"
                >Rules of Hooks</a
              >. Both principles which we are going to discuss revolve around
              the same requirement and that is to <strong>not</strong> change
              the order in which the hooks are rendered at any point of the
              components life cycle. Else undefined behavior is likely to
              happen. If you’re interested to find out why, here’s a great
              <a href="https://reactjs.org/docs/hooks-rules.html#explanation"
                >example</a
              >. The first principle says:
            </p>
            <blockquote>
              <p>
                <strong
                  >Don’t call Hooks inside loops, conditions, or nested
                  functions.</strong
                >
                Instead, always use Hooks at the top level of your React
                function. By following this rule, you ensure that Hooks are
                called in the same order each time a component renders. That’s
                what allows React to correctly preserve the state of Hooks
                between multiple <code>useState</code> and
                <code>useEffect</code> calls.
              </p>
            </blockquote>
            <p>
              It is important to remember that the principles are there to
              protect you. They may even overprotect you, but up to a point it’s
              still better than being under-protecting. An example of an
              overprotective principle is:
            </p>
            <blockquote>
              <p>Don’t call Hooks inside nested functions</p>
            </blockquote>
            <p>
              The point is that it’s imperative to respect the requirement that
              hooks are to be called in the same order, from render A to render
              Z. Invoking hooks inside nested functions does not jeopardizing
              the requirement, unless you use a loop or a conditional inside it.
              Heck, even using a loop or conditional statement without breaking
              the contract. However, in the case of a conditional like an if
              statement, a hook may not get called during a given render causing
              other hooks to be rendered out of order. As with loops, like
              <code>forEach</code>, the length of the array may vary, which
              entails the same negative effects pertaining to conditionals. To
              demonstrate the benevolence of hooks inside nested functions I
              created the following stress test:
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-hooks-nested-function&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>Feel free to experiment yourself.</p>
            <blockquote>
              <p>
                Then, why did the React team declare hooks inside nested
                functions as an anti-pattern?
              </p>
            </blockquote>
            <p>
              It’s easier to check whether a given piece of code, which uses
              hooks, is doing something which may upset the hook invocation
              order if you forbid hooks inside nested functions entirely. On
              this occasion, the React team was probably cornered and had to
              make a decision. They chose the safer path, which is
              understandable. Taking into account React’s widespread adoption
              and the fact that bugs introduced by not following the consistent
              hook order requirement are difficult to debug and reproduce, it’s
              safer to have false positives than undetected issues.
            </p>
            <p>
              Based on the research, it goes without saying, that using hooks in
              async functions are part of the same, code red, category as loops
              and conditionals. Because there’s a high chance that the order in
              which hooks are invoked is going to change from one render to
              another.
            </p>
            <p>And the second principle states:</p>
            <blockquote>
              <p>
                <strong
                  >Don’t call Hooks from regular JavaScript functions.</strong
                >
                Instead, you can:
              </p>
            </blockquote>
            <ul>
              <li>✅ Call Hooks from React function components.</li>
              <li>
                ✅ Call Hooks from custom Hooks (we’ll learn about them
                <a href="https://reactjs.org/docs/hooks-custom.html"
                  >on the next page</a
                >).
              </li>
            </ul>
            <p>To clarify the point:</p>
            <blockquote>
              <p>Don’t call Hooks from regular JavaScript functions</p>
            </blockquote>
            <p>
              If a JavaScript function invokes a hooks inside its body. Firstly,
              you may consider prefixing its name with “use”, if that is not
              already the case. Secondly, and more importantly, the rules of
              hooks now apply to the function which consumes another hook.
              Furthermore, if you use the newly created custom hook inside
              another function, it too becomes a hook inheriting the naming
              convention and rules. And so on, and so forth.
            </p>
            <p>
              As for remembering the rules, luckily for us lazy developers who
              are not fond of learning all the things by heart. Khm, like we had
              to do at school. The React team created an
              <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"
                >eslint plugin</a
              >
              which encompasses the above mentioned rules and basically teaches
              your IDE how to point out when you are doing something borderline.
              Just to see if the <code>useState</code> hook inside a callback is
              something that you did on purpose or a prank. Unfortunately, the
              IDE doesn’t much of a sense of humor.
            </p>
            <p>
              Finally, remember how we talked about rules of hooks being
              overprotective at time… In occasions where the order of hooks is
              guaranteed between renders and eslint still raises an error or a
              warning, you may disable the specific rule for the line which is
              the locus. For arguments sake let’s that you want to disable a
              complaint about a hook inside a nested function, in which case
              you’d target the <code>react-hooks/rules-of-hooks</code> rule:
            </p>
            <p>
              <code>// eslint-disable-line react-hooks/rules-of-hooks</code
              ><br />
              or<br />
              <code
                >// eslint-disable-next-line react-hooks/rules-of-hooks</code
              >
            </p>
            <p>
              One more example where the hooks eslint plugin is being
              overprotective, which I commonly come across, is the
              <code>react-hooks/exhaustive-deps</code> rule. So what’s the
              eslint rule about. It is pretty straightforward:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'

const Hello: React.FC&lt;{ name, fetchName: () =&gt; void }&gt; = ({ name, fetchName }) =&gt; {
  React.useEffect(() =&gt; {
    fetchName()
  }, [])
  return &lt;div&gt;{name}&lt;/div&gt;
}
</code></pre>
            <p>
              Similarly to the previous example it is a case of a rule sanity
              check rule. With the assumption that it is more likely that you
              forgot to declare a dependency, in which case your effect is not
              going to run as often as it may should, depending on the use case.
              Compared to the scenario where you purposefully didn’t declare a
              dependency because you want a certain function to be invoked only
              once, when the component has been mounted. Same as before, you may
              suppress the warning like so:
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'

const Hello: React.FC&lt;{ name, fetchName: () =&gt; void }&gt; = ({ name, fetchName }) =&gt; {
  React.useEffect(() =&gt; {
    fetchName()
  }, []) // eslint-disable-line react-hooks/exhaustive-deps
  return &lt;div&gt;{name}&lt;/div&gt;
}
</code></pre>
            <h2 id="usedebugvalue">useDebugValue</h2>
            <p>
              The last among the hooks, is the <code>useDebugValue</code> hook.
              I only recently found out about the hook, blessed be intellisense,
              and my reaction was along the lines of:
            </p>
            <p>
              “Wait there’s a hook called <code>useDebugValue</code>, that
              sounds intriguing, so what does it do?”
            </p>
            <blockquote>
              <p>
                <code>useDebugValue</code> can be used to display a label for
                custom hooks in React DevTools.
              </p>
            </blockquote>
            <p>
              “I love React DevTools, this must a really great addition to my
              hooks arsenal! Let’s test it out. Okay, I’ve created a custom
              hook. It’s named <code>useValue</code>, so its label in DevTools
              should be equivalent to Value.”
            </p>
            <p>“It is, alright! That wasn’t difficult.”</p>
            <p>
              “Just a second. This means that the default label is
              <code>useValue</code>, let me test it.”
            </p>
            <p>*Comments out useDebug invocation*</p>
            <p>
              “Hmmm, the DevTools still show <code>Value</code>. It must be an
              issue with hot reloading. Let me refresh the page. It’s still the
              same… Let me make sure that I correctly saved the file. It’s still
              the same. And what about the commented out hook - nothings out of
              the ordinary.”
            </p>
            <p>
              So I can to the conclusion that with version <code>4.6.0</code> of
              React DevTools it is no longer necessary to use the
              <code>useDebugValue</code> hook since the name of the hook will be
              properly formatted and used as the label. However, there still may
              be a use case for the <code>useDebugValue</code> hook and it has
              to do with the second parameter the hook accepts. There are no
              mentions of this parameter in the docs, luckily for use the
              <a href="https://npmjs.org/package/@types/react"
                >typings for react</a
              >
              provides more insight.
            </p>
            <blockquote>
              <p>What’s the point of the second parameter?</p>
            </blockquote>
            <p>
              It’s simple - it’s named format and it does exactly that. it’s
              signature depends on the first argument which is the value
              returned by the hook, meaning that if the value were a string the
              type signature of the format function would be
              <code>format: (value: string) =&gt; any</code>. Albeit useful, the
              ability to format the value is not something which you would use
              consistently. What’s more, in the case of the
              <code>useValue</code> hook applying any formatting like
              upper-casing or lower-casing the value would just be confusing.
              Nevertheless, the formatting may play a bigger role when the
              return type of the hook is a complex object.
            </p>
            <p>
              Enough storytelling, let’s get our beaks wet by writing our first
              custom hook! Event though the <code>useDebugValue</code> hook is
              less exciting, writing custom hooks is a thrill.
            </p>
            <iframe
            src=&#34;https://stackblitz.com/edit/react-usedebugvalue&#34;
            width=&#34;100%&#34; height=&#34;500px&#34; />
            <p>
              Notice the usage of the <code>useCallback</code> hook, when
              writing hooks, which are reusable, especially as a library author,
              you may want to pay special attention to writing efficient code in
              every sense of the word. Make the consumers of your custom hook
              look up to you in quality. Importantly, however, nobody writes
              perfect code from the get go, unless they have written a similar
              program before, furthermore a custom hook is useless if it doesn’t
              work correctly. Hence, make sure that your custom hooks work
              before refactoring your code to increase it’s quality.
            </p>
            <p>
              A word which often goes hand to hand with the word refactoring is
              the word <code>TDD</code> and <code>writing test</code>. Just as
              it is difficult to write high quality efficient code in a single
              iteration, it is also difficult to refactor your code without
              first having written the the tests for it. Ask uncle Bob if you
              don’t believe me. No, seriously check out one of his videos on the
              topic of
              <a href="https://www.youtube.com/watch?v=qkblc5WRn-U">TDD</a>.
            </p>
            <p>
              Now that I’ve talked about writing custom hooks and writing test
              in the same sentence, I’ve probably left you wondering how to test
              custom hooks and some of you may also wonder how to test your
              components which consume React hooks or custom hooks. I didn’t
              plan to include this section in the course but I’ll make sure to
              leave room for it. So be on the lookout in of of the future
              section.
            </p>
            <h2 id="creating-your-own-hooks">Creating your own hooks</h2>
            <p>
              Now that we have mastered the basics we are able to move onto more
              advanced topics. Imagine yourself as the painter who has acquired
              all the necessary colors on his or her palette and is ready to
              paint a masterpiece.
            </p>
            <h3 id="implementing-redux-with-usecontext-and-usereducer">
              Implementing redux with useContext and useReducer
            </h3>
            <p>
              Are you used to having a global immutable data store which serves
              as your app single source of truth?<br />
              I am too! So let’s implement a basic version of redux using just 2
              hooks that we mentioned before.
            </p>
            <h3 id="usefetch">useFetch</h3>
            <p>useState and useEffect</p>
            <h3 id="usepagination">usePagination</h3>
            <p>
              It’s getting ever more exiting! In the next section we are going
              to built upon the example from the previous section, however not
              only that. We are also going to take the idea one step further by
              implementing pagination.
            </p>
            <p>useState and useEffect and IntersectionObserver API</p>
            <p>
              Check out
              <a href="https://npmjs.org/package/react-query">react-query</a>
              and/or <a href="https://npmjs.org/package/swr">swr</a> and
              react-window and/or react-virtualized
            </p>
            <h3 id="going-up-a-notch-with-middleware">
              Going up a notch with middleware
            </h3>
            <p>Now we are shifting into the fifth gear when.</p>
            <p>
              If you haven’t done so already check out
              <a href="https://npmjs.org/package/redux-thunk">redux-thunk</a>
              and
              <a href="https://npmjs.org/package/redux-thunk"
                >redux-observable</a
              >
            </p>
            <p>
              You may have noticed that this approach conflicts with relying on
              a hook similar to <code>useFetch</code>. I’ve been a proponent of
              using <code>redux-observable</code> for long time now, because
              performing side effects like network requests in epics, using
              <a href="https://npmjs.org/package/rxjs">rxjs</a> gives you a lot
              of freedom. You are able to denounce, throttle, cancel requests
              and more.
            </p>
            <p>
              However, more recently, I’ve been looking into relying on
              libraries like <code>react-query</code> to handle “server state”
              related matters. There are many carefully though out mechanisms
              which are at your services, out of the box, when using both
              <code>react-query</code> and <code>swr</code>. Let’s go over the
              major concepts, which although possible to implement solely using
              redux-observable and rxjs, require quite a bit of additional
              effort.
            </p>
            <p>
              However, I’ve considered creating a library which would bridge
              that gap for <code>redux-observable</code>. If you are aware of
              something similar which already fulfills such a role, pray let me
              know.
            </p>
            <h3 id="angular-like-services-and-dependency-injection">
              Angular like services and dependency injection
            </h3>
            <p>
              Imagine that you are building an app which is using JWT based
              authentication. The JWT has to be stored on the client after the
              user logs in. However, we cannot store the token as part of the
              global state or any component state for that matter because both
              concepts are tied to individual sessions. Meaning that once the
              user closes the tab in which your app once resided, the
              information about the token is gone. In case that the token has
              not yet expired, it would be inefficient to ask the user to log in
              once they return to the app. We can provide a better user
              experience by storing the token in a place which persists through
              sessions and let the server decide when a token has expired and
              it’s time to reauthenticate. Luckily for us there are many options
              to choose from which fit this description however a popular option
              is to use the <code>localStorage</code> API.
            </p>
            <p><code>useState</code> and <code>useEffect</code></p>
            <h2 id="testing-custom-hooks">Testing custom hooks</h2>
            <p>TODO</p>
            <h3 id="testing-components-which-use-custom-hooks">
              Testing components which use custom hooks
            </h3>
            <p>TODO</p>
            <h2 id="hooks-vs-hocs">Hooks vs HOC’s</h2>
            <p>
              You can read about what the creator of
              <a href="https://github.com/acdlite/recompose">recompose</a>, the
              de facto React HOC’s library, had say about hooks at the top of
              the repository’s README file. However, in a nutshell, React is
              heading towards hooks and recompose is no longer actively
              maintained.
            </p>
            <h3 id="pros-of-hooks">Pros of hooks</h3>
            <ul>
              <li>
                Easier and faster to set up. Take the example of selecting a
                value from the redux store:
              </li>
            </ul>
            <h4 id="selecting-a-value-from-the-state-with-hocs">
              Selecting a value from the state with HOC’s
            </h4>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'
import { connect } from 'react-redux'
import { State, selectName } from '../store'

const Hello: React.FC&lt;{ name: string }&gt; = ({ name }) =&gt; (
  &lt;div&gt;Hello {name}&lt;/div&gt;
)

export const HelloContainer = connect((state: State) =&gt; ({
  name: selectName(state)
}))(Hello)
</code></pre>
            <h4 id="selecting-a-value-from-state-with-hooks">
              Selecting a value from state with hooks
            </h4>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'
import { useSelector } from 'react-redux'
import { State, selectName } from '../store'

const Hello: React.FC = ({ name }) =&gt; {
  const name = useSelector(selectName)
  return (
    &lt;div&gt;Hello {name}&lt;/div&gt;
  )
}
</code></pre>
            <h3 id="cons-of-hooks">Cons of hooks</h3>
            <ul>
              <li>
                Hooks are more difficult to reuse if you want to keep a clear
                separation between container and presentation components. Let’s
                revisit the previous example
              </li>
            </ul>
            <h4 id="create-multiple-components-with-a-single-hoc">
              Create multiple components with a single HOC
            </h4>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'
import { connect } from 'react-redux'
import { State, selectName } from '../store'
import { Hello } from './Hello'
import { Hello1 } from './Hello1'

const connectWithName = connect((state: State) =&gt; ({
  name: selectName(state)
}))

export const HelloContainer = connectWithName(Hello)

export const Hello1Container = connectWithName(Hello1)
</code></pre>
            <p>
              Notice that we didn’t even import <code>React</code> in the
              example above. Because there is no need to, since importing
              <code>React</code> is only required your file contains
              <code>JSX</code> or <code>TSX</code>. What’s more, the file
              extension may be shortened from <code>tsx</code> to
              <code>ts</code>.
            </p>
            <h4 id="create-multiple-components-with-a-single-hook">
              Create multiple components with a single hook
            </h4>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'
import { connect } from 'react-redux'
import { State, selectName } from '../store'
import { Hello } from './Hello'
import { Hello1 } from './Hello1'

export const HelloContainer = () =&gt; {
  const name = useSelector(selectName)
  return &lt;Hello name={name} /&gt;
}

export const Hello1Container = () =&gt; {
  const name = useSelector(selectName)
  return &lt;Hello1 /&gt;
}
</code></pre>
            <p>
              Code-wise there’s not much of a difference, however if we take a
              more holistic approach the point becomes more obvious. Not seldom,
              will you want inject a certain prop or props and spread the rest.
            </p>
            <h4 id="create-multiple-components-with-a-single-hoc-2">
              Create multiple components with a single HOC 2
            </h4>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import { connect } from 'react-redux'
import { State, selectName } from '../store'
import { Dashboard } from './Dashboard'
import { Sidebar } from './Sidebar'

const connectWithName = connect((state: State) =&gt; ({
  name: selectName(state)
}))

export const DashboardContainer = connectWithName(Dashboard)

export const SidebarContainer = connectWithName(Sidebar)
</code></pre>
            <p>The above example has the exact same structure as before.</p>
            <h4 id="create-multiple-components-with-a-single-hook-2">
              Create multiple components with a single hook 2
            </h4>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'
import { connect } from 'react-redux'
import { State, selectName } from '../store'
import { Dashboard } from './Dashboard'
import { Sidebar } from './Sidebar'

export const DashboardContainer = (props: Omit&lt;React.ComponentProps&lt;typeof Dashboard&gt;, 'name'&gt;) =&gt; {
  const name = useSelector(selectName)
  return &lt;Dashboard {...props} name={name} /&gt;
}

export const SidebarContainer = (props: Omit&lt;React.ComponentProps&lt;typeof Sidebar&gt;, 'name'&gt;) =&gt; {
  const name = useSelector(selectName)
  return &lt;Sidebar {...props} name={name} /&gt;
}
</code></pre>
            <p>
              Now the difference is more obvious. There’s some boilerplate which
              is repeated from one case to another. Nevertheless, we already
              know how to easily abstract away such boilerplate code. Yes, we
              can create a higher order component which utilizes a hooks or
              hooks inside it’s body. In the case of
              <code>react-redux</code> you may simply reach for the
              <code>connect</code> HOC. What’s more, creating a HOC which
              utilizes a custom hook is trivial.
            </p>
            <pre
              class="language-tsx"
            ><code class="prism  language-tsx">import React from 'react'
import { Sidebar } from './Sidebar'

export const withModal = &lt;Props extends {}&gt;(Component: React.ComponentType&lt;Props&gt;) =&gt; {
  const ComponentWithModal = (props: Omit&lt;React.ComponentProps&lt;typeof Dashboard&gt;, 'isModalOpen' | 'toggleOpenModal'&gt;) =&gt; {
    const modal = React.useContext(ModalContext)
    return &lt;Component {...props} isModalOpen={modal.isOpen} toggleOpenModal={modal.toggleOpen} /&gt;
  }
  ComponentWithModal.displayName = `withModal(${Component.displayName || Component.name})`
  return ComponentWithModal
}

export const SidebarContainer = withModal(Sidebar)
</code></pre>
            <p>
              The part where we a assign a <code>displayName</code> to the new
              component is optional, However, it aids debugging through the
              usage of
              <a
                href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi"
                >React DevTools</a
              >
            </p>
            <p>
              Observing things from this perspective, HOC’s and hooks can
              coexist with each other in a state of harmony.
            </p>
            <blockquote>
              <p>But, why bother writing pure components?</p>
            </blockquote>
            <p>
              First of all, you can easily instantiate the component with
              randomly generated props with the help of a library like
              <a href="https://nomjs.org/package/faker">faker</a>.
            </p>
            <p>Moreover, many benefits are derived from the above fact.</p>
            <p>
              Firstly your component is easy to unit test using
              <a href="https://npmjs.org/package/@testing-library/react"
                >react testing library</a
              >
              or <a href="https://npmjs.org/package/enzyme">enzyme</a>.
            </p>
            <p>
              Secondly, you can easily reuse a pure component across projects by
              publishing it using a tool like
              <a href="https://npmjs.org/package/@bit/cli">bit</a>
            </p>
            <p>
              Thirdly, you may effortless develop and display your components in
              <a href="https://npmjs.org/package/@storybook/react">storybook</a>
              or a similar environment etc.
            </p>
            <p>
              As a side note, you can still test an impure component which
              consumes a hook, without actually performing any side effects like
              network calls by mocking the function. For example, using
              <a href="https://jestjs.io/docs/en/mock-functions.html">jest</a>.
            </p>
            <p>
              Before we cover the next section, which is really important, let’s
              first glance over the following terms.
            </p>
            <p>
              <a href="https://en.m.wikipedia.org/wiki/Serialization"
                >Serializable</a
              >
              - A message is serializeable if it can be stringified to JSON -
              which is not possible in the case of recursive structures.
            </p>
            <p>
              <a
                href="https://en.m.wikipedia.org/wiki/Command%E2%80%93query_separation"
                >CQRS</a
              >
              - Command Query Responsibility Segregation, states that every
              method should either be a command that performs an action, or a
              query that returns data to the caller, but not both.
            </p>
            <p>
              There is, however, a third approach inspired by microservices.
              Namely, if you think redux as a message broker and your components
              as services. In a nutshell, the main selling point of a
              microservice architecture is that it enables you to keep your
              services decoupled. For example service A, which depends on
              service B, doesn’t have to know how to communicate with service B
              directly. Else if service B were to be replaced with service C
              which behaves completely the same as B, despite the fact, service
              A would have to be altered. Namely, the reference which A holds to
              B would have to be replaced with a reference to C. A message
              broker solves this issue by having the individual service dispatch
              messages which are usually serializeable. The message broker is
              now responsible for passing the messages between services and the
              services themselves just have to know which actions they want to
              listen to and dispatch. You may have noticed that we haven’t
              entirely decoupled our services from the rest of the world (else
              the service would turn into a pure function), we just narrowed
              down it’s dependencies to a minimum. The only reference the
              services have to hold is a reference to the message broker.
              Specifically how to read and write (select and dispatch actions).
              Following the principles of CQRS it is preferable to keep these
              two operations separate. Fortunately, the message broker is not
              something which is often replaced. Even if it did, due to the
              fundamental simplicity of a message broker, the upgrade would be
              large scale but not very complicated. This means that it could be
              automated.
            </p>
            <p>
              In conclusion, hooks are a great addition to the react ecosystem
              and there are plenty of use cases for hooks. Similarly to HOC’s
              hooks may encapsulate logic and/or side effects and keep out code
              DRY. On top of that, hooks can be used inside the body of
              functional component. Taking that into consideration, never again
              do you have to write a class component. Currently, however, with
              the notable exception of error boundaries. For more information
              about this limitation, check out
              <a href="https://overreacted.io/why-isnt-x-a-hook/"
                >why is X not a hook?</a
              >.
            </p>
            <h2 id="migrating-common-libraries-to-hooks">
              Migrating common libraries to hooks
            </h2>
            <p>
              All of the major react libraries, which have previously relied on
              HOC’s, have migrated or are in the of migrating to hooks.
            </p>
            <blockquote>
              <p>
                But does this mean that I have to relearn every single one of
                them.
              </p>
            </blockquote>
            <p>
              The short answer is no. There may be some differences here and
              there, but having come this far into the course, you are
              absolutely equipped for tackling such migrations. Nevertheless, in
              this section we are going to cover some of the most prevalent
              cases and what better way is there to kick off this section than
              to talk about the react integration of redux. Give it up for
              <code>react-redux</code>.
            </p>
            <h3 id="react-redux">react-redux</h3>
            <p>
              I bet that you’ll rarely ever want to connect another component
              using the higher order component API after you’ve got a taste for
              the the hooks <code>react-redux</code> has to offer.
            </p>
            <p><code>connect</code></p>
            <p>TODO</p>
            <p><code>useSelector</code></p>
            <p>TODO</p>
            <p><code>useDispatch</code></p>
            <p>
              Reading this section left a bad aftertaste and if you’re like me,
              the immediate though that crossed my mind was: “Lemme implement
              the <code>useActions</code> hook.” I’ll let you in on a secret.
              Once I implemented the <code>useActions</code> I never looked
              back. So as an added bonus I’ll show you to implement the
              <code>useActions</code> in a type safe manner.
            </p>
            <p><code>useActions</code></p>
            <p>TODO</p>
            <h3 id="react-router">react-router</h3>
            <p><code>withRouter</code></p>
            <p>TODO</p>
            <p><code>useHistory</code></p>
            <p>TODO</p>
            <p><code>useParams</code></p>
            <p>TODO</p>
            <p><code>useRouter</code></p>
            <p>TODO</p>
            <h3 id="material-ui">material-ui</h3>
            <p>
              Material UI is using
              <a href="https://npmjs.org/package/jss">jss</a> under the hood and
              exposes a similar API compared to
              <a href="https://npmjs.org/package/react-jss">react-jss</a> hence
              if you learn one you have learned the other the a significant
              extent safe for certain caveats.
            </p>
            <p><code>makeStyle</code></p>
            <blockquote>
              <p>This is too easy.</p>
            </blockquote>
            <p>
              I agree. So for the next section let’s do something more difficult
              by implementing a prop based animation. In order to make this work
              we are going to overcome a few hurdles along the way, but have
              faith.
            </p>
            <h3 id="xstate">xstate</h3>
            <p>TODO</p>
            <h3 id="styled-components">styled-components</h3>
            <p>TODO</p>
            <h3 id="react-spring">react-spring</h3>
            <p>TODO</p>
            <h2 id="parting-message">Parting message</h2>
            <p>
              Continue to learn and explore. Don’t be afraid to dig into
              documentation, but never stop practicing. And the sky is the limit
              for you.
            </p>
          </div>
        </div>

        <div class="disqus__wrapper">
          <div id="disqus_thread"></div>
        </div>
      </main>
    </section>

    <script src="./index.js"></script>

    <script>
      /*
      (function () { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://mateja176-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
      */
    </script>
    <!--
    <script id="dsq-count-scr" src="//mateja176-blog.disqus.com/count.js" async></script>
	-->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=UA-137872597-1"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-137872597-1');
    </script>
  </body>
</html>
